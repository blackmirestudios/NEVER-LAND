<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Spinning Cube</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #container {
            width: 100vw;
            height: 56.25vw; /* 16:9 aspect ratio */
            max-height: 100vh;
            max-width: 177.78vh; /* 16:9 aspect ratio */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .info {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body class="bg-black">
    <!-- Sunet pași -->
<audio id="footstep" src="footstep.mp3" preload="auto"></audio>
    <!-- Muzică de fundal -->
    <audio id="bg-music" loop hidden>
        <source src="horrormaze.mp3" type="audio/mpeg">
    </audio>
    <div id="loading-screen" class="fixed inset-0 bg-black z-50 hidden flex flex-col items-center justify-center overflow-hidden pixel-bg">
        <!-- Pixel grid background -->
        <div class="absolute inset-0 pixel-grid opacity-20"></div>
        
        <!-- Red scanlines overlay -->
        <div class="absolute inset-0 scanlines opacity-15"></div>
        
        <!-- Pixel border frame -->
        <div class="absolute inset-4 pixel-border"></div>
        
        <!-- Main loading content -->
        <div class="relative z-10 flex flex-col items-center justify-center p-6 w-full max-w-2xl">
            <!-- Pixelated title with glow effect -->
            <div class="relative mb-10">
                <div class="pixel-title-container">
                    <h1 class="pixel-title-text glitch-text" data-text="SYSTEM BOOT">SYSTEM BOOT</h1>
                    <div class="pixel-title-shadow">SYSTEM BOOT</div>
                </div>
                <div class="text-red-400 text-center text-lg mt-3 font-mono tracking-widest pixel-subtitle">
                    INITIALIZING MAZE PROTOCOL
                </div>
            </div>
            
            <!-- Pixel progress container -->
            <div class="w-full max-w-md mb-8">
                <!-- Progress bar with pixel borders -->
                <div class="pixel-progress-container">
                    <div class="pixel-progress-border">
                        <div id="loading-bar" class="pixel-progress-bar" style="width: 0%">
                            <div class="pixel-progress-fill"></div>
                            <div class="pixel-progress-glow"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Percentage with pixel font -->
                <div class="text-center mt-4">
                    <span id="loading-percentage" class="pixel-percentage">0%</span>
                </div>
            </div>
            
            <!-- Pixel status messages -->
            <div class="pixel-status-container">
                <div class="pixel-status-item">
                    <span class="pixel-status-icon">■</span>
                    <span class="pixel-status-text">LOADING TERRAIN DATA</span>
                    <span class="pixel-status-dots">...</span>
                </div>
                <div class="pixel-status-item">
                    <span class="pixel-status-icon">■</span>
                    <span class="pixel-status-text">INITIALIZING ENTITY AI</span>
                    <span class="pixel-status-dots">...</span>
                </div>
                <div class="pixel-status-item">
                    <span class="pixel-status-icon">■</span>
                    <span class="pixel-status-text">CALIBRATING SENSORS</span>
                    <span class="pixel-status-dots">...</span>
                </div>
            </div>
            
            <!-- Pixel warning box -->
            <div class="pixel-warning-box mt-8">
                <div class="pixel-warning-header">
                    <span class="pixel-warning-icon">⚠</span>
                    SECURITY ALERT
                </div>
                <div class="pixel-warning-content">
                    <div>ENTITY DETECTED IN VICINITY</div>
                    <div>MAINTAIN VISUAL CONTACT</div>
                    <div>DO NOT APPROACH</div>
                </div>
            </div>
            
            <!-- Bottom status bar -->
            <div class="absolute bottom-4 left-0 right-0 text-center">
                <div class="pixel-bottom-status">
                    <span class="pixel-status-pulse">●</span>
                    <span class="pixel-status-text">PREPARING SIMULATION ENVIRONMENT</span>
                </div>
            </div>
        </div>
        
        <!-- Pixel particles for background animation -->
        <div class="particles-container absolute inset-0"></div>
    </div>

    <div id="main-menu" class="fixed inset-0 bg-black z-50 overflow-hidden">
        <div id="sinister-effect" class="absolute inset-0 pointer-events-none"></div>
        
        <!-- Galactic Stars with Chromatic Aberration -->
        <div class="absolute inset-0 overflow-hidden stars-container">
            <!-- Stars will be generated by JavaScript -->
        </div>
        
        <style>
            .star {
                position: absolute;
                border-radius: 50%;
                animation: twinkle 4s infinite ease-in-out;
                filter: blur(0.5px);
            }
            
            .star::before, .star::after {
                content: '';
                position: absolute;
                border-radius: 50%;
                animation: inherit;
            }
            
            .star::before {
                width: 100%;
                height: 100%;
                background: rgba(255, 0, 0, 0.6);
                transform: translate(-1px, -1px);
                z-index: -1;
            }
            
            .star::after {
                width: 100%;
                height: 100%;
                background: rgba(0, 255, 255, 0.6);
                transform: translate(1px, 1px);
                z-index: -2;
            }
            
            @keyframes twinkle {
                0%, 100% { 
                    opacity: 0.3; 
                    transform: scale(0.95);
                }
                50% { 
                    opacity: 1; 
                    transform: scale(1.05);
                }
            }
            
            @keyframes star-drift {
                0% {
                    transform: translateY(-100px) rotate(0deg);
                }
                100% {
                    transform: translateY(100vh) rotate(360deg);
                }
            }
        </style>
        
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                const container = document.querySelector('.stars-container');
                const starCount = 200;
                
                for (let i = 0; i < starCount; i++) {
                    const star = document.createElement('div');
                    star.className = 'star';
                    
                    // Random size between 1-4px
                    const size = 1 + Math.random() * 3;
                    star.style.width = `${size}px`;
                    star.style.height = `${size}px`;
                    
                    // Random position
                    star.style.left = `${Math.random() * 100}%`;
                    star.style.top = `${Math.random() * 100}%`;
                    
                    // Random animation delay and duration
                    const delay = Math.random() * 4;
                    const duration = 8 + Math.random() * 12;
                    star.style.animationDelay = `${delay}s`;
                    star.style.animationDuration = `${duration}s`;
                    
                    // Random movement animation
                    star.style.animation = `twinkle ${duration}s infinite ease-in-out ${delay}s, 
                                          star-drift ${duration * 2}s infinite linear ${delay}s`;
                    
                    // Random color (white with tint variations)
                    const hue = Math.random() * 60 - 30; // -30 to 30 degrees from white
                    star.style.backgroundColor = `hsla(${hue}, 70%, 90%, ${0.6 + Math.random() * 0.4})`;
                    
                    container.appendChild(star);
                }
            });
        </script>

        <!-- Blood splatter overlay -->
        <div class="absolute inset-0 pointer-events-none">
            <div class="absolute top-10 left-10 w-32 h-32 opacity-30">
                <svg viewBox="0 0 100 100" class="w-full h-full">
                    <path d="M30,20 Q40,5 50,20 T70,20 Q80,10 85,30 T75,60 Q60,80 50,75 T25,60 Q20,40 30,20" 
                          fill="#8a0303" class="blood-splatter"/>
                </svg>
            </div>
            <div class="absolute top-20 right-20 w-24 h-24 opacity-40">
                <svg viewBox="0 0 100 100" class="w-full h-full">
                    <path d="M20,30 Q5,40 20,50 T20,70 Q10,80 30,85 T60,75 Q80,60 75,50 T60,25 Q40,20 20,30" 
                          fill="#8a0303" class="blood-splatter"/>
                </svg>
            </div>
            <div class="absolute bottom-20 left-1/4 w-28 h-28 opacity-25">
                <svg viewBox="0 0 100 100" class="w-full h-full">
                    <path d="M40,15 Q25,25 40,40 T30,60 Q15,70 25,85 T50,80 Q70,70 75,50 T60,25 Q50,10 40,15" 
                          fill="#8a0303" class="blood-splatter"/>
                </svg>
            </div>
            <div class="absolute bottom-10 right-1/3 w-20 h-20 opacity-35">
                <svg viewBox="0 0 100 100" class="w-full h-full">
                    <path d="M25,35 Q10,45 25,60 T15,75 Q5,85 20,90 T45,85 Q60,75 65,55 T50,30 Q35,25 25,35" 
                          fill="#8a0303" class="blood-splatter"/>
                </svg>
            </div>
        </div>

        <!-- Creepy floating apparitions -->
        <div class="absolute inset-0 pointer-events-none">
            <div class="ghost-apparition" style="top: 20%; left: 15%; animation-delay: 2s;"></div>
            <div class="ghost-apparition" style="top: 60%; right: 25%; animation-delay: 5s;"></div>
            <div class="ghost-apparition" style="bottom: 30%; left: 30%; animation-delay: 8s;"></div>
            <div class="ghost-apparition" style="top: 40%; right: 15%; animation-delay: 11s;"></div>
        </div>

        <!-- Distorted whispering text overlay -->
        <div class="absolute inset-0 pointer-events-none flex items-center justify-center">
            <div class="whispering-text">
                <span class="whisper-word">RUN</span>
                <span class="whisper-word">ESCAPE</span>
                <span class="whisper-word">HELP</span>
                <span class="whisper-word">DIE</span>
                <span class="whisper-word">FEAR</span>
            </div>
        </div>

        <!-- Pulsating heart beat effect -->
        <div class="absolute inset-0 heartbeat-overlay pointer-events-none"></div>

        <!-- Main content -->
        <div class="relative h-full flex flex-col items-center justify-center">
            <!-- Title with enhanced horror effects -->
            <div class="relative mb-12 enhanced-glitch">
                <h1 class="text-8xl font-bold tracking-widest text-center sinister-font neon-title title-outline">
                    <span class="neon-flicker glitch-text" data-text="MAZE PROTOCOL">MAZE PROTOCOL</span>
                    <div class="blood-drip"></div>
                </h1>
                <div class="text-red-400 text-center text-lg mt-4 tracking-widest font-mono neon-subtitle">
                    <span class="flicker-slow glitch-text" data-text="TERMINAL ESCAPE">TERMINAL ESCAPE</span>
                </div>
            </div>

            <!-- Start button with improved design -->
            <div class="flex flex-col items-center gap-6">
                <div class="relative group">
                    <div class="absolute -inset-1 bg-red-600 blur opacity-75 group-hover:opacity-100 transition-opacity duration-300 rounded-full"></div>
                    <button id="start-button" class="relative px-12 py-4 bg-black text-red-400 border-2 border-red-600 
                                                   hover:bg-red-600 hover:text-black transition-all duration-300 
                                                   text-xl font-mono tracking-widest transform group-hover:scale-105
                                                   rounded-full">
                        ENTER THE MAZE
                    </button>
                </div>
                
                <!-- Settings button -->
                <div class="relative group">
                    <div class="absolute -inset-1 bg-purple-600 blur opacity-50 group-hover:opacity-75 transition-opacity duration-300 rounded-full"></div>
                    <button id="settings-button" class="relative px-8 py-2 bg-black text-purple-400 border border-purple-600 
                                                   hover:bg-purple-600 hover:text-black transition-all duration-300 
                                                   text-sm font-mono tracking-widest transform group-hover:scale-105
                                                   rounded-full">
                        DIFFICULTY
                    </button>
                </div>
                
                <!-- Graphics Settings button -->
                <div class="relative group">
                    <div class="absolute -inset-1 bg-green-600 blur opacity-50 group-hover:opacity-75 transition-opacity duration-300 rounded-full"></div>
                    <button id="graphics-button" class="relative px-8 py-2 bg-black text-green-400 border border-green-600 
                                                   hover:bg-green-600 hover:text-black transition-all duration-300 
                                                   text-sm font-mono tracking-widest transform group-hover:scale-105
                                                   rounded-full">
                        GRAPHICS
                    </button>
                </div>
                
                <!-- Instructions button -->
                <div class="relative group">
                    <div class="absolute -inset-1 bg-blue-600 blur opacity-50 group-hover:opacity-75 transition-opacity duration-300 rounded-full"></div>
                    <button id="instructions-button" class="relative px-8 py-2 bg-black text-blue-400 border border-blue-600 
                                                   hover:bg-blue-600 hover:text-black transition-all duration-300 
                                                   text-sm font-mono tracking-widest transform group-hover:scale-105
                                                   rounded-full">
                        INSTRUCTIONS
                    </button>
                </div>
            </div>

            <!-- Enhanced bottom text with horror elements -->
            <div class="absolute bottom-8 left-0 right-0 text-center">
                <p class="text-red-400/60 text-sm font-mono tracking-widest glitch-text" data-text="WARNING: CONTAINS DISTURBING CONTENT">
                    WARNING: CONTAINS DISTURBING CONTENT
                </p>
                <div class="mt-2 text-red-300/40 text-xs font-mono tracking-widest animate-pulse">
                    SYSTEM ACTIVATED...
                </div>
            </div>
            
            <!-- Studio credit -->
            <div class="absolute bottom-4 left-4">
                <p class="text-gray-500/50 text-xs font-mono tracking-widest">
                    BlackMire Studios
                </p>
            </div>
        </div>
    </div>
    <div id="container" class="hidden"></div>
    <div id="timer" class="fixed top-4 right-4 text-red-500 font-mono text-xl tracking-widest hidden">
        <div class="vhs-timer">05:00</div>
    </div>
    <div id="vignette" class="vignette"></div>
    <div id="crosshair" class="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-4 h-4 pointer-events-none hidden">
        <div class="absolute top-1/2 left-0 w-full h-px bg-red-600 transform -translate-y-1/2"></div>
        <div class="absolute left-1/2 top-0 h-full w-px bg-red-600 transform -translate-x-1/2"></div>
    </div>

    <script id="vhsFragmentShader" type="x-shader/x-fragment">
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform vec2 resolution;
        varying vec2 vUv;

        // Random and noise functions for VHS effect
        float rand(vec2 co) {
            return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
        }

        void main() {
            // Fisheye distortion
            vec2 center = vec2(0.5, 0.5);
            vec2 uv = vUv - center;
            float dist = length(uv);
            float fisheyeStrength = 0.5; // Adjust for stronger/weaker fisheye effect
            
            // Apply fisheye distortion
            vec2 distortedUv = uv * (1.0 - fisheyeStrength * dist * dist);
            distortedUv += center;
            
            // Time-based effects
            float timeFactor = time * 0.5;
            
            // VHS noise
            float noise = rand(distortedUv + mod(timeFactor, 100.0));
            noise = pow(noise, 2.0) * 0.1;
            
            // Scan lines
            float scanLine = sin(distortedUv.y * resolution.y * 0.7 + timeFactor * 10.0) * 0.02;
            
            // Color channel offset (VHS tracking error effect)
            vec2 offset = vec2(0.002 * sin(timeFactor * 0.7), 0.002 * cos(timeFactor * 0.8));
            float r = texture2D(tDiffuse, distortedUv + offset).r;
            float g = texture2D(tDiffuse, distortedUv).g;
            float b = texture2D(tDiffuse, distortedUv - offset).b;
            
            // Combine with noise and scanlines
            vec3 color = vec3(r, g, b);
            color += noise * 0.8;
            color += scanLine * 1.2;
            
            // Increase contrast and saturation
            color = mix(color, vec3(dot(color, vec3(0.299, 0.587, 0.114))), 0.05);
            color = color * 1.2 - 0.1;
            color = clamp(color, 0.0, 1.0);
            
            gl_FragColor = vec4(color, 1.0);
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Creepster&display=swap');
        
        .sinister-font {
            font-family: 'Arial Black', 'Arial Bold', Gadget, sans-serif;
            text-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000, 0 0 15px #ff0000;
            letter-spacing: 2px;
            font-weight: 900;
            text-transform: uppercase;
        }
        
        /* Professional neon title effects */
        .neon-title {
            color: #ff3864;
            text-shadow: 
                0 0 7px #ff3864,
                0 0 14px #ff3864,
                0 0 21px #ff3864,
                0 0 28px #ff0000,
                0 0 42px #ff0000,
                0 0 56px #ff0000,
                0 0 70px #ff0000,
                0 0 84px #ff0000,
                0 0 98px #ff0000,
                0 0 112px #ff0000,
                -2px -2px 4px rgba(51, 0, 0, 0.8),
                2px -2px 4px rgba(51, 0, 0, 0.8),
                -2px 2px 4px rgba(51, 0, 0, 0.8),
                2px 2px 4px rgba(51, 0, 0, 0.8);
            animation: neon-pulse 1.8s infinite alternate ease-in-out;
            position: relative;
            z-index: 1;
        }

        .neon-title::before {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            color: transparent;
            z-index: -1;
            text-shadow: 
                0 0 15px rgba(255, 56, 100, 0.5),
                0 0 25px rgba(255, 56, 100, 0.3),
                0 0 35px rgba(255, 56, 100, 0.2),
                0 0 45px rgba(255, 0, 0, 0.1),
                0 0 55px rgba(255, 0, 0, 0.05);
            animation: neon-glow 3s infinite alternate-reverse ease-in-out;
        }

        .neon-title::after {
            content: '';
            position: absolute;
            top: 120%;
            left: -10%;
            width: 120%;
            height: 20px;
            background: radial-gradient(ellipse at center, 
                rgba(255, 56, 100, 0.8) 0%, 
                rgba(255, 56, 100, 0.4) 30%, 
                transparent 70%);
            border-radius: 50%;
            filter: blur(8px);
            z-index: -2;
            transform: perspective(100px) rotateX(80deg);
            animation: neon-light 2s infinite alternate ease-in-out;
        }

        @keyframes neon-pulse {
            0%, 20%, 60%, 100% {
                opacity: 0.95;
                text-shadow: 
                    0 0 7px #ff3864,
                    0 0 14px #ff3864,
                    0 0 21px #ff3864,
                    0 0 28px #ff0000,
                    0 0 42px #ff0000,
                    0 0 56px #ff0000,
                    0 0 70px #ff0000,
                    0 0 84px #ff0000,
                    -2px -2px 4px rgba(51, 0, 0, 0.8),
                    2px -2px 4px rgba(51, 0, 0, 0.8),
                    -2px 2px 4px rgba(51, 0, 0, 0.8),
                    2px 2px 4px rgba(51, 0, 0, 0.8);
            }
            40%, 80% {
                opacity: 1;
                text-shadow: 
                    0 0 10px #ff3864,
                    0 0 20px #ff3864,
                    0 0 30px #ff3864,
                    0 0 40px #ff0000,
                    0 0 70px #ff0000,
                    0 0 80px #ff0000,
                    0 0 100px #ff0000,
                    0 0 120px #ff0000,
                    -3px -3px 6px rgba(51, 0, 0, 0.9),
                    3px -3px 6px rgba(51, 0, 0, 0.9),
                    -3px 3px 6px rgba(51, 0, 0, 0.9),
                    3px 3px 6px rgba(51, 0, 0, 0.9);
            }
        }

        @keyframes neon-glow {
            0%, 100% {
                opacity: 0.7;
                transform: translate(0, 0) scale(1);
            }
            50% {
                opacity: 0.9;
                transform: translate(2px, -2px) scale(1.02);
            }
        }

        @keyframes neon-light {
            0%, 100% {
                opacity: 0.6;
                transform: perspective(100px) rotateX(80deg) scale(0.95);
            }
            50% {
                opacity: 0.8;
                transform: perspective(100px) rotateX(80deg) scale(1.05);
            }
        }

        /* Pixel loading screen styles */
        .pixel-bg {
            background: linear-gradient(45deg, #0a0a0a 25%, #111 25%, #111 50%, #0a0a0a 50%, #0a0a0a 75%, #111 75%, #111);
            background-size: 8px 8px;
        }
        
        .pixel-grid {
            background-image: 
                linear-gradient(to right, rgba(255,0,0,0.05) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(255,0,0,0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        .scanlines {
            background: linear-gradient(to bottom, 
                transparent 0%, 
                rgba(255,0,0,0.03) 50%, 
                transparent 100%);
            background-size: 100% 3px;
            animation: scanline 1s linear infinite;
        }
        
        .pixel-border {
            border: 4px solid #330000;
            box-shadow: 
                0 0 0 2px #660000,
                inset 0 0 0 2px #660000,
                0 0 20px rgba(255,0,0,0.3);
        }
        
        .pixel-title-container {
            position: relative;
            text-align: center;
        }
        
        .pixel-title-text {
            font-family: 'Courier New', monospace;
            font-size: 3.5rem;
            font-weight: bold;
            color: #ff3864;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 
                3px 3px 0 #000,
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000;
            position: relative;
            z-index: 2;
        }
        
        .pixel-title-shadow {
            position: absolute;
            top: 4px;
            left: 4px;
            font-family: 'Courier New', monospace;
            font-size: 3.5rem;
            font-weight: bold;
            color: #330000;
            text-transform: uppercase;
            letter-spacing: 4px;
            z-index: 1;
        }
        
        .pixel-subtitle {
            color: #ff3864;
            text-shadow: 
                2px 2px 0 #000,
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000;
            letter-spacing: 3px;
        }
        
        .pixel-progress-container {
            position: relative;
            padding: 8px;
            background: #1a1a1a;
            border: 3px solid #330000;
            box-shadow: 
                inset 0 0 0 2px #660000,
                0 4px 0 #000;
        }
        
        .pixel-progress-border {
            background: #0a0a0a;
            border: 2px solid #000;
            padding: 4px;
            height: 24px;
        }
        
        .pixel-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #330000, #660000, #990000);
            position: relative;
            overflow: hidden;
            transition: width 0.3s ease-out;
        }
        
        .pixel-progress-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255,255,255,0.2) 50%, 
                transparent 100%);
            animation: progress-shine 1.5s infinite;
        }
        
        .pixel-progress-glow {
            position: absolute;
            top: 0;
            right: 0;
            height: 100%;
            width: 20px;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255,0,0,0.8),
                transparent);
            animation: progress-glow 1s infinite;
        }
        
        .pixel-percentage {
            font-family: 'Courier New', monospace;
            font-size: 1.5rem;
            font-weight: bold;
            color: #ff3864;
            text-shadow: 
                2px 2px 0 #000,
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000;
        }
        
        .pixel-status-container {
            background: rgba(0,0,0,0.7);
            border: 3px solid #330000;
            padding: 12px;
            width: 100%;
            max-width: 400px;
        }
        
        .pixel-status-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-family: 'Courier New', monospace;
            color: #ff3864;
            text-shadow: 1px 1px 0 #000;
        }
        
        .pixel-status-icon {
            color: #ff0000;
            margin-right: 8px;
            animation: status-pulse 1s infinite;
        }
        
        .pixel-status-text {
            flex: 1;
            font-size: 0.9rem;
            letter-spacing: 1px;
        }
        
        .pixel-status-dots {
            color: #ff3864;
            animation: dots-animation 2s infinite;
        }
        
        .pixel-warning-box {
            background: #330000;
            border: 3px solid #660000;
            padding: 0;
            width: 100%;
            max-width: 350px;
            box-shadow: 0 4px 0 #000;
        }
        
        .pixel-warning-header {
            background: #660000;
            padding: 8px 12px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #ff3864;
            text-shadow: 1px 1px 0 #000;
            text-align: center;
            letter-spacing: 2px;
        }
        
        .pixel-warning-icon {
            margin-right: 8px;
            animation: warning-pulse 0.5s infinite;
        }
        
        .pixel-warning-content {
            padding: 12px;
            text-align: center;
            font-family: 'Courier New', monospace;
            color: #ff3864;
            text-shadow: 1px 1px 0 #000;
            line-height: 1.6;
        }
        
        .pixel-bottom-status {
            font-family: 'Courier New', monospace;
            color: #ff3864;
            text-shadow: 1px 1px 0 #000;
            letter-spacing: 2px;
            font-size: 0.9rem;
        }
        
        .pixel-status-pulse {
            color: #ff0000;
            margin-right: 8px;
            animation: status-pulse 0.8s infinite;
        }
        
        @keyframes progress-shine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        @keyframes progress-glow {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
        
        @keyframes status-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        @keyframes dots-animation {
            0% { content: '.'; }
            33% { content: '..'; }
            66% { content: '...'; }
            100% { content: '.'; }
        }
        
        @keyframes warning-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .title-outline {
            position: relative;
            text-shadow: 
                -2px -2px 0 #000,
                2px -2px 0 #000,
                -2px 2px 0 #000,
                2px 2px 0 #000,
                -3px -3px 6px rgba(0,0,0,0.8),
                3px -3px 6px rgba(0,0,0,0.8),
                -3px 3px 6px rgba(0,0,0,0.8),
                3px 3px 6px rgba(0,0,0,0.8);
        }

        .neon-subtitle {
            color: #ff3864;
            text-shadow: 
                0 0 4px #ff3864,
                0 0 7px #ff3864,
                0 0 11px #ff3864;
            animation: neon-subtitle-pulse 3s infinite alternate;
        }

        @keyframes neon-subtitle-pulse {
            from {
                opacity: 0.7;
                text-shadow: 
                    0 0 4px #ff3864,
                    0 0 7px #ff3864,
                    0 0 11px #ff3864;
            }
            to {
                opacity: 1;
                text-shadow: 
                    0 0 8px #ff3864,
                    0 0 14px #ff3864,
                    0 0 18px #ff3864,
                    0 0 22px #ff0000;
            }
        }

        .neon-flicker {
            animation: flicker 1.5s infinite alternate;
        }

        .flicker-slow {
            animation: flicker 3s infinite alternate;
        }

        @keyframes flicker {
            0%, 18%, 22%, 25%, 53%, 57%, 100% {
                text-shadow: 
                    0 0 7px #ff3864,
                    0 0 10px #ff3864,
                    0 0 21px #ff3864,
                    0 0 42px #ff0000,
                    0 0 82px #ff0000,
                    0 0 92px #ff0000,
                    0 0 102px #ff0000,
                    0 0 151px #ff0000;
            }
            20%, 24%, 55% {        
                text-shadow: 
                    0 0 2px #ff3864,
                    0 0 5px #ff3864,
                    0 0 7px #ff3864,
                    0 0 21px #ff0000;
            }
        }

        /* Pulsing glow effect */
        @keyframes pulse {
            0% {
                opacity: 0.7;
            }
            50% {
                opacity: 1;
            }
            100% {
                opacity: 0.7;
            }
        }

        
        #sinister-effect {
            background: 
                radial-gradient(circle at 20% 30%, rgba(255, 0, 0, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(139, 0, 0, 0.25) 0%, transparent 50%),
                linear-gradient(45deg, rgba(0,0,0,0.95) 0%, transparent 100%),
                url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="30" fill="%233a2a1e"/><rect y="30" width="100" height="30" fill="%234d1a1a"/><rect y="60" width="100" height="40" fill="%233a2a1e"/><rect x="50" y="0" width="50" height="30" fill="%234d1a1a"/><rect x="50" y="30" width="50" height="30" fill="%233a2a1e"/><rect x="50" y="60" width="50" height="40" fill="%234d1a1a"/></svg>');
            background-size: 200px 200px;
            animation: sinister-pulse 4s infinite alternate;
            mix-blend-mode: overlay;
        }
        
        @keyframes sinister-pulse {
            0% { 
                opacity: 0.4;
                filter: hue-rotate(0deg);
            }
            50% {
                opacity: 0.6;
                filter: hue-rotate(180deg);
            }
            100% { 
                opacity: 0.3;
                filter: hue-rotate(360deg);
            }
        }

        @keyframes move-right {
            0% { transform: translateX(-100px); opacity: 0; }
            20% { opacity: 0.4; }
            80% { opacity: 0.4; }
            100% { transform: translateX(100vw); opacity: 0; }
        }
        @keyframes move-down {
            0% { transform: translateY(-100px); opacity: 0; }
            10% { opacity: 0.4; }
            90% { opacity: 0.4; }
            100% { transform: translateY(100vh); opacity: 0; }
        }
        @keyframes move-up {
            0% { transform: translateY(100px); opacity: 0; }
            20% { opacity: 0.4; }
            80% { opacity: 0.4; }
            100% { transform: translateY(-100vh); opacity: 0; }
        }
        .animate-move-right {
            animation: move-right 15s linear infinite;
        }
        .animate-move-down {
            animation: move-down 20s linear infinite;
        }
        .animate-move-up {
            animation: move-up 18s linear infinite;
        }

        /* Blood splatter animation */
        .blood-splatter {
            animation: blood-drip 8s infinite alternate;
        }

        @keyframes blood-drip {
            0% { opacity: 0.2; transform: scale(0.95); }
            50% { opacity: 0.4; transform: scale(1.05); }
            100% { opacity: 0.3; transform: scale(1); }
        }

        /* Ghost apparitions */
        .ghost-apparition {
            position: absolute;
            width: 80px;
            height: 120px;
            background: linear-gradient(transparent 0%, rgba(255,255,255,0.1) 20%, transparent 40%);
            mask: radial-gradient(ellipse at center, rgba(0,0,0,1) 40%, transparent 70%);
            -webkit-mask: radial-gradient(ellipse at center, rgba(0,0,0,1) 40%, transparent 70%);
            opacity: 0;
            animation: ghost-appear 12s infinite;
        }

        @keyframes ghost-appear {
            0%, 100% { 
                opacity: 0; 
                transform: translateY(20px) scale(0.8); 
                filter: blur(10px);
            }
            15%, 25% { 
                opacity: 0.7; 
                transform: translateY(0) scale(1); 
                filter: blur(2px);
            }
            40% { 
                opacity: 0; 
                transform: translateY(-20px) scale(1.2); 
                filter: blur(15px);
            }
        }

        /* Whispering text effect */
        .whispering-text {
            position: relative;
            font-family: 'Creepster', cursive;
            font-size: 2rem;
            color: rgba(255,0,0,0.3);
            text-shadow: 0 0 10px rgba(255,0,0,0.5);
            opacity: 0;
            animation: whisper-fade 15s infinite;
        }

        .whisper-word {
            position: absolute;
            opacity: 0;
            animation: whisper-words 20s infinite;
        }

        .whisper-word:nth-child(1) { animation-delay: 2s; }
        .whisper-word:nth-child(2) { animation-delay: 6s; }
        .whisper-word:nth-child(3) { animation-delay: 10s; }
        .whisper-word:nth-child(4) { animation-delay: 14s; }
        .whisper-word:nth-child(5) { animation-delay: 18s; }

        @keyframes whisper-fade {
            0%, 100% { opacity: 0; transform: scale(0.8); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }

        @keyframes whisper-words {
            0%, 100% { 
                opacity: 0; 
                transform: translateX(-100px) rotate(-10deg) scale(0.5);
                filter: blur(20px);
            }
            10%, 20% { 
                opacity: 0.8; 
                transform: translateX(0) rotate(0) scale(1);
                filter: blur(2px);
            }
            30% { 
                opacity: 0; 
                transform: translateX(100px) rotate(10deg) scale(1.5);
                filter: blur(20px);
            }
        }

        /* Heartbeat pulse effect */
        .heartbeat-overlay {
            background: radial-gradient(circle, rgba(255,0,0,0) 0%, rgba(255,0,0,0) 50%);
            animation: heartbeat 2s infinite;
        }

        /* Pixel button styles */
        .pixel-buttons-container {
            margin-top: 3rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
        }

        .pixel-button-wrapper {
            position: relative;
            margin: 0;
        }

        .pixel-button-bg {
            position: absolute;
            top: 4px;
            left: 4px;
            width: 100%;
            height: 100%;
            z-index: -1;
            transition: transform 0.1s ease;
            image-rendering: pixelated;
        }

        .pixel-corners {
            position: relative;
            border-radius: 0;
            border: 2px solid #000 !important;
            transition: all 0.1s ease;
            box-shadow: 
                0 4px 0 rgba(0, 0, 0, 0.8),
                0 0 0 2px rgba(255, 255, 255, 0.1) inset;
            transform: translateZ(0);
            image-rendering: pixelated;
            outline: none;
        }

        .pixel-corners::before {
            content: '';
            position: absolute;
            top: -6px;
            left: -6px;
            right: -6px;
            bottom: -6px;
            border: 2px solid #000;
            z-index: -2;
        }

        .pixel-corners:hover {
            box-shadow: 
                0 2px 0 rgba(0, 0, 0, 0.8),
                0 0 0 2px rgba(255, 255, 255, 0.2) inset;
            transform: translateY(2px);
        }

        .pixel-corners:hover + .pixel-button-bg {
            transform: translate(2px, 2px);
        }

        .pixel-corners:active {
            box-shadow: 
                0 0px 0 rgba(0, 0, 0, 0.8),
                0 0 0 4px rgba(255, 255, 255, 0.1) inset;
            transform: translateY(4px);
        }

        .pixel-corners:active + .pixel-button-bg {
            transform: translate(4px, 4px);
        }

        /* Pixel text effect */
        .pixel-text {
            text-shadow: 
                2px 2px 0 #000,
                -2px -2px 0 #000,
                2px -2px 0 #000,
                -2px 2px 0 #000;
            letter-spacing: 2px;
            font-weight: bold;
            display: block;
        }

        /* Specific button colors */
        #start-button .pixel-text {
            color: #ff3864;
            text-shadow: 
                2px 2px 0 #000,
                -2px -2px 0 #000,
                2px -2px 0 #000,
                -2px 2px 0 #000,
                0 0 8px #ff3864;
        }

        #settings-button .pixel-text {
            color: #c678dd;
            text-shadow: 
                1px 1px 0 #000,
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000,
                0 0 6px #c678dd;
        }

        #instructions-button .pixel-text {
            color: #61afef;
            text-shadow: 
                1px 1px 0 #000,
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000,
                0 0 6px #61afef;
        }

        /* Button hover effects */
        #start-button:hover .pixel-text {
            color: #000;
            text-shadow: 
                2px 2px 0 #ff3864,
                -2px -2px 0 #ff3864,
                2px -2px 0 #ff3864,
                -2px 2px 0 #ff3864;
        }

        #settings-button:hover .pixel-text {
            color: #000;
            text-shadow: 
                1px 1px 0 #c678dd,
                -1px -1px 0 #c678dd,
                1px -1px 0 #c678dd,
                -1px 1px 0 #c678dd;
        }

        #instructions-button:hover .pixel-text {
            color: #000;
            text-shadow: 
                1px 1px 0 #61afef,
                -1px -1px 0 #61afef,
                1px -1px 0 #61afef,
                -1px 1px 0 #61afef;
        }

        /* Pixel button animations */
        @keyframes pixel-pulse {
            0%, 100% {
                box-shadow: 
                    0 4px 0 rgba(0, 0, 0, 0.8),
                    0 0 0 2px rgba(255, 255, 255, 0.1) inset,
                    0 0 10px rgba(255, 56, 100, 0.5);
            }
            50% {
                box-shadow: 
                    0 4px 0 rgba(0, 0, 0, 0.8),
                    0 0 0 2px rgba(255, 255, 255, 0.1) inset,
                    0 0 20px rgba(255, 56, 100, 0.8);
            }
        }

        #start-button {
            animation: pixel-pulse 2s infinite;
        }

        @keyframes heartbeat {
            0% { 
                background: radial-gradient(circle, rgba(255,0,0,0) 0%, rgba(255,0,0,0) 50%);
                opacity: 0;
            }
            45% { 
                background: radial-gradient(circle, rgba(255,0,0,0.1) 0%, rgba(255,0,0,0) 50%);
                opacity: 0.3;
            }
            50% { 
                background: radial-gradient(circle, rgba(255,0,0,0.2) 0%, rgba(255,0,0,0) 50%);
                opacity: 0.5;
            }
            55% { 
                background: radial-gradient(circle, rgba(255,0,0,0.1) 0%, rgba(255,0,0,0) 50%);
                opacity: 0.3;
            }
            100% { 
                background: radial-gradient(circle, rgba(255,0,0,0) 0%, rgba(255,0,0,0) 50%);
                opacity: 0;
            }
        }

        /* Enhanced glitch effects */
        .enhanced-glitch {
            position: relative;
        }

        .enhanced-glitch::before,
        .enhanced-glitch::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.8;
        }

        .enhanced-glitch::before {
            animation: enhanced-glitch-anim-1 0.6s infinite;
            color: #ff00ff;
            z-index: -1;
            clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
        }

        .enhanced-glitch::after {
            animation: enhanced-glitch-anim-2 0.6s infinite;
            color: #00ffff;
            z-index: -2;
            clip-path: polygon(0 60%, 100% 60%, 100% 100%, 0 100%);
        }

        @keyframes enhanced-glitch-anim-1 {
            0% { transform: translate(0); }
            20% { transform: translate(-5px, 3px); }
            40% { transform: translate(-5px, -3px); }
            60% { transform: translate(5px, 3px); }
            80% { transform: translate(5px, -3px); }
            100% { transform: translate(0); }
        }

        @keyframes enhanced-glitch-anim-2 {
            0% { transform: translate(0); }
            20% { transform: translate(3px, -5px); }
            40% { transform: translate(3px, 5px); }
            60% { transform: translate(-3px, -5px); }
            80% { transform: translate(-3px, 5px); }
            100% { transform: translate(0); }
        }

        /* Blood drip effect on title */
        .blood-drip {
            position: absolute;
            top: 100%;
            left: 50%;
            width: 2px;
            height: 0;
            background: linear-gradient(to bottom, #8a0303, transparent);
            animation: drip 8s infinite;
        }

        @keyframes drip {
            0% { height: 0; opacity: 0; }
            10% { height: 50px; opacity: 1; }
            20% { height: 100px; opacity: 0.8; }
            30% { height: 150px; opacity: 0.6; }
            40% { height: 200px; opacity: 0.4; }
            50% { height: 250px; opacity: 0.2; }
            60% { height: 300px; opacity: 0; }
            100% { height: 300px; opacity: 0; }
        }

        /* Glitch effect animations */
        @keyframes glitch-effect {
            0% { transform: translate(0); opacity: 0; }
            5% { transform: translate(-2px, 2px); opacity: 0.3; }
            10% { transform: translate(2px, -2px); opacity: 0.3; }
            15% { transform: translate(-2px, -2px); opacity: 0.3; }
            20% { transform: translate(2px, 2px); opacity: 0.3; }
            25% { transform: translate(0); opacity: 0; }
            100% { transform: translate(0); opacity: 0; }
        }

        @keyframes glitch-lines {
            0% { opacity: 0; background-position: 0 0; }
            10% { opacity: 0.1; }
            15% { opacity: 0.3; background-position: 0 50%; }
            20% { opacity: 0.1; }
            25% { opacity: 0; background-position: 0 100%; }
            100% { opacity: 0; }
        }

        @keyframes text-glitch {
            0% { transform: translate(0); }
            2% { transform: translate(-2px, 2px); }
            4% { transform: translate(2px, -2px); }
            6% { transform: translate(-2px, -2px); }
            8% { transform: translate(2px, 2px); }
            10% { transform: translate(0); }
            100% { transform: translate(0); }
        }

        .vhs-timer {
            text-shadow: 0 0 5px #ff0000;
            animation: vhs-glitch 1s infinite;
        }

        .glitch-text {
            position: relative;
            animation: text-glitch 20s infinite;
        }

        .glitch-text::before,
        .glitch-text::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.8;
        }

        .glitch-text::before {
            animation: glitch-animation-1 0.6s infinite;
            color: #ff00ff;
            z-index: -1;
            clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
        }

        .glitch-text::after {
            animation: glitch-animation-2 0.6s infinite;
            color: #00ffff;
            z-index: -2;
            clip-path: polygon(0 60%, 100% 60%, 100% 100%, 0 100%);
        }

        .glitch-layers {
            pointer-events: none;
        }

        .glitch-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: currentColor;
            opacity: 0;
            mix-blend-mode: difference;
        }

        .glitch-layer--1 {
            animation: glitch-layer-1 2s infinite;
            color: #ff0000;
        }

        .glitch-layer--2 {
            animation: glitch-layer-2 3s infinite;
            color: #0000ff;
        }

        .loading-bar-shine {
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255,255,255,0.4) 50%, 
                transparent 100%);
            animation: loading-shine 1.5s infinite;
        }

        @keyframes loading-shine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        @keyframes glitch-animation-1 {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        @keyframes glitch-animation-2 {
            0% { transform: translate(0); }
            20% { transform: translate(2px, -2px); }
            40% { transform: translate(2px, 2px); }
            60% { transform: translate(-2px, -2px); }
            80% { transform: translate(-2px, 2px); }
            100% { transform: translate(0); }
        }

        @keyframes glitch-layer-1 {
            0%, 100% { opacity: 0; transform: translate(0); }
            10% { opacity: 0.1; transform: translate(-2px, 1px); }
            20% { opacity: 0; transform: translate(0); }
            30% { opacity: 0.1; transform: translate(2px, -1px); }
            40% { opacity: 0; transform: translate(0); }
            50% { opacity: 0.1; transform: translate(-1px, 2px); }
            60% { opacity: 0; transform: translate(0); }
            70% { opacity: 0.1; transform: translate(1px, -2px); }
            80% { opacity: 0; transform: translate(0); }
            90% { opacity: 0.1; transform: translate(-2px, -1px); }
        }

        @keyframes glitch-layer-2 {
            0%, 100% { opacity: 0; transform: translate(0); }
            15% { opacity: 0.1; transform: translate(3px, -2px); }
            25% { opacity: 0; transform: translate(0); }
            35% { opacity: 0.1; transform: translate(-3px, 2px); }
            45% { opacity: 0; transform: translate(0); }
            55% { opacity: 0.1; transform: translate(2px, 3px); }
            65% { opacity: 0; transform: translate(0); }
            75% { opacity: 0.1; transform: translate(-2px, -3px); }
            85% { opacity: 0; transform: translate(0); }
            95% { opacity: 0.1; transform: translate(3px, 2px); }
        }

        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: inset 0 0 150px rgba(0,0,0,0.98);
            pointer-events: none;
            z-index: 100;
        }
        
        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .try-again-btn {
            padding: 15px 30px;
            background-color: #ff0000;
            color: white;
            border: none;
            font-size: 24px;
            font-family: 'Creepster', cursive;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
        }
        
        .try-again-btn:hover {
            background-color: #990000;
            transform: scale(1.05);
        }

        .vhs-scanline {
            background: linear-gradient(
                to bottom,
                transparent 0%,
                rgba(255, 0, 0, 0.05) 50%,
                transparent 100%
            );
            background-size: 100% 4px;
            animation: scanline 2s linear infinite;
        }

        /* Pixel corners for modals */
        .pixel-corners {
            border-radius: 0;
            border: 4px solid !important;
            box-shadow: 
                0 8px 0 rgba(0, 0, 0, 0.8),
                0 0 0 4px rgba(255, 255, 255, 0.1) inset;
            position: relative;
        }

        .pixel-corners::before {
            content: '';
            position: absolute;
            top: -8px;
            left: -8px;
            right: -8px;
            bottom: -8px;
            border: 2px solid #000;
            z-index: -1;
        }

        /* Difficulty option selection effect */
        .difficulty-option input:checked + label {
            border-color: #fff !important;
        }

        .difficulty-option input:checked + label div {
            transform: scale(1.05);
        }

        /* Pixel button effect */
        /* Pixel buttons container */
        .pixel-buttons-container {
            margin-top: 3rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
        }

        .pixel-button-wrapper {
            position: relative;
            margin: 0;
        }

        .pixel-button-bg {
            position: absolute;
            top: 4px;
            left: 4px;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #330000, #660000, #990000);
            z-index: -1;
            transition: transform 0.1s ease;
            image-rendering: pixelated;
        }

        .pixel-corners {
            position: relative;
            border-radius: 0;
            border: 2px solid #000 !important;
            transition: all 0.1s ease;
            box-shadow: 
                0 4px 0 rgba(0, 0, 0, 0.8),
                0 0 0 2px rgba(255, 255, 255, 0.1) inset;
            transform: translateZ(0);
            image-rendering: pixelated;
            outline: none;
        }

        .pixel-corners::before {
            content: '';
            position: absolute;
            top: -6px;
            left: -6px;
            right: -6px;
            bottom: -6px;
            border: 2px solid #000;
            z-index: -2;
        }

        .pixel-corners:hover {
            box-shadow: 
                0 2px 0 rgba(0, 0, 0, 0.8),
                0 0 0 2px rgba(255, 255, 255, 0.2) inset;
            transform: translateY(2px);
        }

        .pixel-corners:hover + .pixel-button-bg {
            transform: translate(2px, 2px);
        }

        .pixel-corners:active {
            box-shadow: 
                0 0px 0 rgba(0, 0, 0, 0.8),
                0 0 0 4px rgba(255, 255, 255, 0.1) inset;
            transform: translateY(4px);
        }

        .pixel-corners:active + .pixel-button-bg {
            transform: translate(4px, 4px);
        }

        /* Pixel text effect */
        .pixel-text {
            text-shadow: 
                2px 2px 0 #000,
                -2px -2px 0 #000,
                2px -2px 0 #000,
                -2px 2px 0 #000;
            letter-spacing: 2px;
            font-weight: bold;
            display: block;
        }

        /* Specific button colors */
        #start-button .pixel-text {
            color: #ff3864;
            text-shadow: 
                2px 2px 0 #000,
                -2px -2px 0 #000,
                2px -2px 0 #000,
                -2px 2px 0 #000,
                0 0 8px #ff3864;
        }

        #settings-button .pixel-text {
            color: #c678dd;
            text-shadow: 
                1px 1px 0 #000,
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000,
                0 0 6px #c678dd;
        }

        #instructions-button .pixel-text {
            color: #61afef;
            text-shadow: 
                1px 1px 0 #000,
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000,
                0 0 6px #61afef;
        }

        /* Button hover effects */
        #start-button:hover .pixel-text {
            color: #000;
            text-shadow: 
                2px 2px 0 #ff3864,
                -2px -2px 0 #ff3864,
                2px -2px 0 #ff3864,
                -2px 2px 0 #ff3864;
        }

        #settings-button:hover .pixel-text {
            color: #000;
            text-shadow: 
                1px 1px 0 #c678dd,
                -1px -1px 0 #c678dd,
                1px -1px 0 #c678dd,
                -1px 1px 0 #c678dd;
        }

        #instructions-button:hover .pixel-text {
            color: #000;
            text-shadow: 
                1px 1px 0 #61afef,
                -1px -1px 0 #61afef,
                1px -1px 0 #61afef,
                -1px 1px 0 #61afef;
        }

        /* Pixel button animations */
        @keyframes pixel-pulse {
            0%, 100% {
                box-shadow: 
                    0 4px 0 rgba(0, 0, 0, 0.8),
                    0 0 0 2px rgba(255, 255, 255, 0.1) inset,
                    0 0 10px rgba(255, 56, 100, 0.5);
            }
            50% {
                box-shadow: 
                    0 4px 0 rgba(0, 0, 0, 0.8),
                    0 0 0 2px rgba(255, 255, 255, 0.1) inset,
                    0 0 20px rgba(255, 56, 100, 0.8);
            }
        }

        #start-button {
            animation: pixel-pulse 2s infinite;
        }

        @keyframes scanline {
            0% { background-position: 0 0; }
            100% { background-position: 0 100%; }
        }

        @keyframes vhs-glitch {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
        }
    </style>

    <!-- Enhanced Instructions Modal -->
    <div id="instructions-modal" class="fixed inset-0 bg-black bg-opacity-95 z-50 hidden flex items-center justify-center p-4">
        <div class="relative w-full max-w-4xl bg-black border-4 border-blue-600 p-8 pixel-corners">
            <!-- VHS Scanline Effect -->
            <div class="vhs-scanline absolute inset-0 pointer-events-none"></div>
            
            <!-- Pixel Border Decoration -->
            <div class="absolute -inset-4 border-2 border-blue-400 opacity-60 pointer-events-none"></div>
            
            <!-- Header with Professional Styling -->
            <div class="text-center mb-8 relative">
                <div class="absolute -top-6 left-1/2 transform -translate-x-1/2 w-12 h-1 bg-blue-500"></div>
                <h2 class="text-blue-500 text-4xl font-bold tracking-widest pixel-text mb-2" 
                    style="text-shadow: 3px 3px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000;">
                    OPERATION MANUAL
                </h2>
                <div class="text-blue-300 font-mono text-sm tracking-widest opacity-80">
                    SURVIVAL PROTOCOL v2.4.7
                </div>
            </div>

            <!-- Content Grid -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-8">
                <!-- Controls Section -->
                <div class="bg-black/50 border-2 border-blue-800 p-6 pixel-corners">
                    <h3 class="text-blue-400 text-xl font-mono tracking-widest mb-4 pixel-text"
                        style="text-shadow: 2px 2px 0 #000;">
                        🎮 CONTROL SCHEMATIC
                    </h3>
                    <div class="space-y-3 text-blue-300 font-mono text-sm">
                        <div class="flex justify-between items-center border-b border-blue-700 pb-2">
                            <span>MOVEMENT FORWARD</span>
                            <span class="text-blue-500 font-bold">W KEY</span>
                        </div>
                        <div class="flex justify-between items-center border-b border-blue-700 pb-2">
                            <span>MOVEMENT BACKWARD</span>
                            <span class="text-blue-500 font-bold">S KEY</span>
                        </div>
                        <div class="flex justify-between items-center border-b border-blue-700 pb-2">
                            <span>STRAF LEFT</span>
                            <span class="text-blue-500 font-bold">A KEY</span>
                        </div>
                        <div class="flex justify-between items-center border-b border-blue-700 pb-2">
                            <span>STRAF RIGHT</span>
                            <span class="text-blue-500 font-bold">D KEY</span>
                        </div>
                        <div class="flex justify-between items-center border-b border-blue-700 pb-2">
                            <span>SPRINT MODULE</span>
                            <span class="text-blue-500 font-bold">SHIFT KEY</span>
                        </div>
                        <div class="flex justify-between items-center border-b border-blue-700 pb-2">
                            <span>VISUAL INPUT</span>
                            <span class="text-blue-500 font-bold">MOUSE</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span>FLASHLIGHT TOGGLE</span>
                            <span class="text-blue-500 font-bold">F KEY</span>
                        </div>
                    </div>
                </div>

                <!-- Objective Section -->
                <div class="bg-black/50 border-2 border-blue-800 p-6 pixel-corners">
                    <h3 class="text-blue-400 text-xl font-mono tracking-widest mb-4 pixel-text"
                        style="text-shadow: 2px 2px 0 #000;">
                        🎯 PRIMARY OBJECTIVE
                    </h3>
                    <div class="text-blue-300 font-mono text-sm space-y-4">
                        <p>Navigate the labyrinthine structure and locate the EMERALD EXIT ZONE before temporal parameters expire.</p>
                        <div class="bg-blue-900/30 p-3 border-l-4 border-blue-500">
                            <span class="text-blue-400 font-bold">WARNING:</span> The entity designated "SLENDERMAN" exhibits hostile behavior. Maintain minimum safe distance of 2 units.
                        </div>
                        <p>Acoustic monitoring is advised - auditory cues may indicate proximal threat presence.</p>
                    </div>
                </div>

                <!-- Strategy Section -->
                <div class="bg-black/50 border-2 border-blue-800 p-6 pixel-corners">
                    <h3 class="text-blue-400 text-xl font-mono tracking-widest mb-4 pixel-text"
                        style="text-shadow: 2px 2px 0 #000;">
                        ⚡ STRATEGIC PROTOCOLS
                    </h3>
                    <div class="space-y-3 text-blue-300 font-mono text-sm">
                        <div class="flex items-start space-x-3">
                            <span class="text-blue-500 font-bold">→</span>
                            <span>Illumination systems attract attention. Use sparingly.</span>
                        </div>
                        <div class="flex items-start space-x-3">
                            <span class="text-blue-500 font-bold">→</span>
                            <span>Entity manifests periodically. Constant mobility is recommended.</span>
                        </div>
                        <div class="flex items-start space-x-3">
                            <span class="text-blue-500 font-bold">→</span>
                            <span>Sprint module has limited duration and requires cooldown cycles.</span>
                        </div>
                        <div class="flex items-start space-x-3">
                            <span class="text-blue-500 font-bold">→</span>
                            <span>Wall structures are impenetrable. Navigate via available pathways.</span>
                        </div>
                    </div>
                </div>

                <!-- Technical Section -->
                <div class="bg-black/50 border-2 border-blue-800 p-6 pixel-corners">
                    <h3 class="text-blue-400 text-xl font-mono tracking-widest mb-4 pixel-text"
                        style="text-shadow: 2px 2px 0 #000;">
                        🔧 SYSTEM STATUS
                    </h3>
                    <div class="space-y-2 text-blue-300 font-mono text-sm">
                        <div class="flex justify-between">
                            <span>Visual Interface</span>
                            <span class="text-blue-500">OPERATIONAL</span>
                        </div>
                        <div class="flex justify-between">
                            <span>Audio Systems</span>
                            <span class="text-blue-500">ONLINE</span>
                        </div>
                        <div class="flex justify-between">
                            <span>Navigation</span>
                            <span class="text-blue-500">CALIBRATED</span>
                        </div>
                        <div class="flex justify-between">
                            <span>Threat Detection</span>
                            <span class="text-red-400">ACTIVE</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Close Button -->
            <div class="text-center">
                <button id="close-instructions" class="px-12 py-4 bg-blue-600 text-black font-mono tracking-widest 
                    border-2 border-black hover:bg-blue-400 hover:text-black transition-all duration-200 
                    pixel-corners pixel-button relative group">
                    <span class="relative z-10">CONFIRM ACKNOWLEDGEMENT</span>
                    <div class="absolute inset-0 bg-blue-400 opacity-0 group-hover:opacity-100 transition-opacity duration-200"></div>
                </button>
            </div>
        </div>
    </div>

    <!-- Graphics Settings Modal -->
    <div id="graphics-modal" class="fixed inset-0 bg-black bg-opacity-95 z-50 hidden flex items-center justify-center p-4">
        <div class="relative w-full max-w-2xl bg-black border-4 border-green-600 p-8 pixel-corners">
            <!-- VHS Scanline Effect -->
            <div class="vhs-scanline absolute inset-0 pointer-events-none"></div>
            
            <!-- Pixel Border Decoration -->
            <div class="absolute -inset-4 border-2 border-green-400 opacity-60 pointer-events-none"></div>
            
            <!-- Header -->
            <div class="text-center mb-8 relative">
                <div class="absolute -top-6 left-1/2 transform -translate-x-1/2 w-12 h-1 bg-green-500"></div>
                <h2 class="text-green-500 text-4xl font-bold tracking-widest pixel-text mb-2"
                    style="text-shadow: 3px 3px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000;">
                    GRAPHICS SETTINGS
                </h2>
                <div class="text-green-300 font-mono text-sm tracking-widest opacity-80">
                    VISUAL CONFIGURATION
                </div>
            </div>

            <!-- Graphics Options Grid -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                <!-- Quality Settings -->
                <div class="bg-black/50 border-2 border-green-600 p-6 pixel-corners">
                    <h3 class="text-green-400 text-xl font-mono tracking-widest mb-4 pixel-text"
                        style="text-shadow: 2px 2px 0 #000;">
                        QUALITY PRESET
                    </h3>
                    <div class="space-y-3">
                        <div class="graphics-option">
                            <input type="radio" id="quality-low" name="quality" value="low" class="mr-2">
                            <label for="quality-low" class="text-green-300 font-mono cursor-pointer">LOW</label>
                        </div>
                        <div class="graphics-option">
                            <input type="radio" id="quality-medium" name="quality" value="medium" class="mr-2" checked>
                            <label for="quality-medium" class="text-green-300 font-mono cursor-pointer">MEDIUM</label>
                        </div>
                        <div class="graphics-option">
                            <input type="radio" id="quality-high" name="quality" value="high" class="mr-2">
                            <label for="quality-high" class="text-green-300 font-mono cursor-pointer">HIGH</label>
                        </div>
                    </div>
                </div>

                <!-- Resolution Settings -->
                <div class="bg-black/50 border-2 border-green-600 p-6 pixel-corners">
                    <h3 class="text-green-400 text-xl font-mono tracking-widest mb-4 pixel-text"
                        style="text-shadow: 2px 2px 0 #000;">
                        RESOLUTION
                    </h3>
                    <div class="space-y-3">
                        <div class="graphics-option">
                            <input type="radio" id="resolution-720" name="resolution" value="720" class="mr-2">
                            <label for="resolution-720" class="text-green-300 font-mono cursor-pointer">1280x720</label>
                        </div>
                        <div class="graphics-option">
                            <input type="radio" id="resolution-1080" name="resolution" value="1080" class="mr-2" checked>
                            <label for="resolution-1080" class="text-green-300 font-mono cursor-pointer">1920x1080</label>
                        </div>
                        <div class="graphics-option">
                            <input type="radio" id="resolution-native" name="resolution" value="native" class="mr-2">
                            <label for="resolution-native" class="text-green-300 font-mono cursor-pointer">NATIVE</label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Apply Button -->
            <div class="text-center">
                <button id="apply-graphics" class="px-12 py-4 bg-green-600 text-black font-mono tracking-widest 
                    border-2 border-black hover:bg-green-400 hover:text-black transition-all duration-200 
                    pixel-corners pixel-button relative group">
                    <span class="relative z-10">APPLY SETTINGS</span>
                    <div class="absolute inset-0 bg-green-400 opacity-0 group-hover:opacity-100 transition-opacity duration-200"></div>
                </button>
            </div>

            <!-- Close Button -->
            <button id="close-graphics" class="absolute top-4 right-4 text-green-400 hover:text-green-200 transition-colors">
                <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                </svg>
            </button>
        </div>
    </div>

    <!-- Enhanced Settings Modal -->
    <div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-95 z-50 hidden flex items-center justify-center p-4">
        <div class="relative w-full max-w-2xl bg-black border-4 border-purple-600 p-8 pixel-corners">
            <!-- VHS Scanline Effect -->
            <div class="vhs-scanline absolute inset-0 pointer-events-none"></div>
            
            <!-- Pixel Border Decoration -->
            <div class="absolute -inset-4 border-2 border-purple-400 opacity-60 pointer-events-none"></div>
            
            <!-- Header -->
            <div class="text-center mb-8 relative">
                <div class="absolute -top-6 left-1/2 transform -translate-x-1/2 w-12 h-1 bg-purple-500"></div>
                <h2 class="text-purple-500 text-4xl font-bold tracking-widest pixel-text mb-2"
                    style="text-shadow: 3px 3px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000;">
                    SECURITY PROTOCOL
                </h2>
                <div class="text-purple-300 font-mono text-sm tracking-widest opacity-80">
                    THREAT LEVEL CONFIGURATION
                </div>
            </div>

            <!-- Difficulty Options Grid -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                <!-- Easy -->
                <div class="difficulty-option bg-black/50 border-2 border-green-600 p-6 pixel-corners relative group hover:border-green-400 transition-all duration-300">
                    <input type="radio" id="easy-difficulty" name="difficulty" value="120" class="absolute opacity-0">
                    <label for="easy-difficulty" class="cursor-pointer">
                        <div class="text-center">
                            <div class="text-green-500 text-2xl font-mono mb-2 pixel-text group-hover:text-green-300"
                                style="text-shadow: 2px 2px 0 #000;">
                                ALPHA PROTOCOL
                            </div>
                            <div class="text-green-400 text-sm font-mono mb-3">(BEGINNER)</div>
                            <div class="text-green-300 text-xs font-mono mb-4">
                                120 SECOND TIME WINDOW<br>
                                REDUCED ENTITY AGGRESSION<br>
                                ENHANCED VISIBILITY
                            </div>
                            <div class="text-green-500 text-lg font-mono">
                                02:00
                            </div>
                        </div>
                    </label>
                </div>

                <!-- Medium -->
                <div class="difficulty-option bg-black/50 border-2 border-blue-600 p-6 pixel-corners relative group hover:border-blue-400 transition-all duration-300">
                    <input type="radio" id="medium-difficulty" name="difficulty" value="180" class="absolute opacity-0">
                    <label for="medium-difficulty" class="cursor-pointer">
                        <div class="text-center">
                            <div class="text-blue-500 text-2xl font-mono mb-2 pixel-text group-hover:text-blue-300"
                                style="text-shadow: 2px 2px 0 #000;">
                                BETA PROTOCOL
                            </div>
                            <div class="text-blue-400 text-sm font-mono mb-3">(INTERMEDIATE)</div>
                            <div class="text-blue-300 text-xs font-mono mb-4">
                                180 SECOND TIME WINDOW<br>
                                STANDARD ENTITY BEHAVIOR<br>
                                NORMAL VISIBILITY
                            </div>
                            <div class="text-blue-500 text-lg font-mono">
                                03:00
                            </div>
                        </div>
                    </label>
                </div>

                <!-- Hard -->
                <div class="difficulty-option bg-black/50 border-2 border-orange-600 p-6 pixel-corners relative group hover:border-orange-400 transition-all duration-300">
                    <input type="radio" id="hard-difficulty" name="difficulty" value="300" class="absolute opacity-0 checked:border-orange-400" checked>
                    <label for="hard-difficulty" class="cursor-pointer">
                        <div class="text-center">
                            <div class="text-orange-500 text-2xl font-mono mb-2 pixel-text group-hover:text-orange-300"
                                style="text-shadow: 2px 2px 0 #000;">
                                GAMMA PROTOCOL
                            </div>
                            <div class="text-orange-400 text-sm font-mono mb-3">(ADVANCED)</div>
                            <div class="text-orange-300 text-xs font-mono mb-4">
                                300 SECOND TIME WINDOW<br>
                                ELEVATED ENTITY AGGRESSION<br>
                                REDUCED VISIBILITY
                            </div>
                            <div class="text-orange-500 text-lg font-mono">
                                05:00
                            </div>
                        </div>
                    </label>
                </div>

                <!-- Nightmare -->
                <div class="difficulty-option bg-black/50 border-2 border-red-600 p-6 pixel-corners relative group hover:border-red-400 transition-all duration-300">
                    <input type="radio" id="nightmare-difficulty" name="difficulty" value="480" class="absolute opacity-0">
                    <label for="nightmare-difficulty" class="cursor-pointer">
                        <div class="text-center">
                            <div class="text-red-500 text-2xl font-mono mb-2 pixel-text group-hover:text-red-300"
                                style="text-shadow: 2px 2px 0 #000;">
                                OMEGA PROTOCOL
                            </div>
                            <div class="text-red-400 text-sm font-mono mb-3">(EXPERT)</div>
                            <div class="text-red-300 text-xs font-mono mb-4">
                                480 SECOND TIME WINDOW<br>
                                MAXIMUM ENTITY AGGRESSION<br>
                                MINIMAL VISIBILITY
                            </div>
                            <div class="text-red-500 text-lg font-mono">
                                08:00
                            </div>
                        </div>
                    </label>
                </div>
            </div>

            <!-- Confirm Button -->
            <div class="text-center">
                <button id="close-settings" class="px-12 py-4 bg-purple-600 text-black font-mono tracking-widest 
                    border-2 border-black hover:bg-purple-400 hover:text-black transition-all duration-200 
                    pixel-corners pixel-button relative group">
                    <span class="relative z-10">ACTIVATE PROTOCOL</span>
                    <div class="absolute inset-0 bg-purple-400 opacity-0 group-hover:opacity-100 transition-opacity duration-200"></div>
                </button>
            </div>
        </div>
    </div>

    <div id="history-modal" class="fixed inset-0 bg-black bg-opacity-90 z-50 hidden flex items-center justify-center">
        <div class="max-w-2xl bg-black border-2 border-red-600 p-8 relative">
            <div class="vhs-scanline absolute inset-0 pointer-events-none"></div>
            <h2 class="text-red-500 text-3xl mb-6 font-mono tracking-widest">CLOWN'S DARK HISTORY</h2>
            <div class="text-red-400 font-mono text-sm leading-relaxed">
                <p class="mb-4">Born in 1972 as Timothy Birch, the clown showed disturbing tendencies from childhood. His first victim was his own mother at age 12.</p>
                <p class="mb-4">After escaping from a mental institution in 1995, he began his killing spree across rural America, always leaving a twisted smile painted on his victims.</p>
                <p class="mb-4">The authorities found his underground lair in 2003 containing over 30 bodies, each carefully preserved and posed in grotesque clown costumes.</p>
                <p>He vanished in 2008 after killing 3 guards during a prison transfer. You've just survived an encounter with one of America's most notorious serial killers.</p>
            </div>
            <button id="close-history" class="mt-8 px-6 py-2 bg-red-600 text-black font-mono hover:bg-red-800 transition rounded-full">
                CLOSE FILE
            </button>
        </div>
    </div>

    <script>
        // Main menu functionality
        document.addEventListener('DOMContentLoaded', function() {
            // Settings button functionality
            document.getElementById('settings-button').addEventListener('click', function() {
                document.getElementById('main-menu').classList.add('hidden');
                document.getElementById('settings-modal').classList.remove('hidden');
                
                // Check the current difficulty radio button
                document.querySelector(`input[value="${gameTime}"]`).checked = true;
            });

            // Difficulty selection handler
            document.getElementById('close-settings').addEventListener('click', function() {
                const selected = document.querySelector('input[name="difficulty"]:checked');
                gameTime = parseInt(selected.value);
                
                // Set difficulty name for reference
                if (gameTime === 120) selectedDifficulty = 'easy';
                else if (gameTime === 180) selectedDifficulty = 'medium';
                else if (gameTime === 300) selectedDifficulty = 'hard';
                else if (gameTime === 480) selectedDifficulty = 'nightmare';
                
                // Update game settings based on difficulty
                updateGameSettings(selectedDifficulty);
                
                document.getElementById('settings-modal').classList.add('hidden');
                document.getElementById('main-menu').classList.remove('hidden');
            });

            function updateGameSettings(difficulty) {
                // Reset all settings first
                scene.fog = new THREE.FogExp2(0x330000, 0.05);
                
                // Update based on difficulty
                switch(difficulty) {
                    case 'easy':
                        // White fog for better visibility in easy mode
                        scene.fog = new THREE.FogExp2(0xdddddd, 0.03);
                        // Recreate floor without blood
                        if (floor) scene.remove(floor);
                        floor = createFloorWithoutBlood();
                        scene.add(floor);
                        break;
                        
                    case 'medium':
                        // Grey fog and remove blood stains
                        scene.fog = new THREE.FogExp2(0x666666, 0.05);
                        if (floor) scene.remove(floor);
                        floor = createFloorWithoutBlood();
                        scene.add(floor);
                        break;
                        
                    case 'hard':
                        // Keep original settings (red fog with blood)
                        scene.fog = new THREE.FogExp2(0x330000, 0.05);
                        if (floor) scene.remove(floor);
                        floor = createOriginalFloor();
                        scene.add(floor);
                        break;
                        
                    case 'nightmare':
                        // Denser red fog and increased entity aggression
                        scene.fog = new THREE.FogExp2(0x330000, 0.08);
                        if (floor) scene.remove(floor);
                        floor = createOriginalFloor();
                        scene.add(floor);
                        // Slenderman will be more aggressive
                        slendermanSpeed = 0.025;
                        // Make entity spawn more frequently for expert mode
                        slendermanAppearTimerMax = 6; // Reduced from 10 seconds
                        // Change flashlight color to red
                        flashlight.color.set(0xff0000);
                        break;
                }
            }

            function createFloorWithoutBlood() {
                const canvas = document.createElement('canvas');
                canvas.width = 4096;
                canvas.height = 4096;
                const ctx = canvas.getContext('2d');
                
                // Base dark brown color
                ctx.fillStyle = '#3A2A1E';
                ctx.fillRect(0, 0, 4096, 4096);
                
                // Create pixelated dirt pattern without blood
                const pixelSize = 32;
                const cols = 4096 / pixelSize;
                const rows = 4096 / pixelSize;
                
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        const shade = 30 + Math.random() * 40;
                        const r = Math.max(0, Math.min(255, shade));
                        const g = Math.max(0, Math.min(255, shade - 10 + Math.random() * 10));
                        const b = Math.max(0, Math.min(255, shade - 15 + Math.random() * 5));
                        
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                    }
                }
                
                // Add some scattered darker patches
                for (let i = 0; i < 150; i++) {
                    const x = Math.floor(Math.random() * cols) * pixelSize;
                    const y = Math.floor(Math.random() * rows) * pixelSize;
                    const size = (1 + Math.floor(Math.random() * 4)) * pixelSize;
                    
                    ctx.fillStyle = '#2A1A0E';
                    ctx.fillRect(x, y, size, size);
                }
                
                // Add some scattered lighter patches
                for (let i = 0; i < 75; i++) {
                    const x = Math.floor(Math.random() * cols) * pixelSize;
                    const y = Math.floor(Math.random() * rows) * pixelSize;
                    const size = (1 + Math.floor(Math.random() * 3)) * pixelSize;
                    
                    ctx.fillStyle = '#4A3A2E';
                    ctx.fillRect(x, y, size, size);
                }
                
                // Add some small rocks/stones
                for (let i = 0; i < 50; i++) {
                    const x = Math.floor(Math.random() * cols) * pixelSize;
                    const y = Math.floor(Math.random() * rows) * pixelSize;
                    const size = (1 + Math.floor(Math.random() * 2)) * pixelSize;
                    
                    ctx.fillStyle = '#555555';
                    ctx.fillRect(x, y, size, size);
                }

                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(16, 16);
                texture.magFilter = THREE.NearestFilter;
                texture.minFilter = THREE.NearestFilter;
                
                return new THREE.Mesh(
                    new THREE.PlaneGeometry(150, 150),
                    new THREE.MeshStandardMaterial({ 
                        map: texture,
                        side: THREE.DoubleSide
                    })
                );
            }

            function createOriginalFloor() {
                // Recreate the original floor with blood
                const canvas = document.createElement('canvas');
                canvas.width = 4096;
                canvas.height = 4096;
                const ctx = canvas.getContext('2d');
                
                // Base dark brown color
                ctx.fillStyle = '#3A2A1E';
                ctx.fillRect(0, 0, 4096, 4096);
                
                // Create pixelated dirt pattern with blood
                const pixelSize = 32;
                const cols = 4096 / pixelSize;
                const rows = 4096 / pixelSize;
                
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        const shade = 30 + Math.random() * 40;
                        const r = Math.max(0, Math.min(255, shade));
                        const g = Math.max(0, Math.min(255, shade - 10 + Math.random() * 10));
                        const b = Math.max(0, Math.min(255, shade - 15 + Math.random() * 5));
                        
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                    }
                }
                
                // Add some scattered darker patches
                for (let i = 0; i < 150; i++) {
                    const x = Math.floor(Math.random() * cols) * pixelSize;
                    const y = Math.floor(Math.random() * rows) * pixelSize;
                    const size = (1 + Math.floor(Math.random() * 4)) * pixelSize;
                    
                    ctx.fillStyle = '#2A1A0E';
                    ctx.fillRect(x, y, size, size);
                }
                
                // Add some scattered lighter patches
                for (let i = 0; i < 75; i++) {
                    const x = Math.floor(Math.random() * cols) * pixelSize;
                    const y = Math.floor(Math.random() * rows) * pixelSize;
                    const size = (1 + Math.floor(Math.random() * 3)) * pixelSize;
                    
                    ctx.fillStyle = '#4A3A2E';
                    ctx.fillRect(x, y, size, size);
                }
                
                // Add some small rocks/stones
                for (let i = 0; i < 50; i++) {
                    const x = Math.floor(Math.random() * cols) * pixelSize;
                    const y = Math.floor(Math.random() * rows) * pixelSize;
                    const size = (1 + Math.floor(Math.random() * 2)) * pixelSize;
                    
                    ctx.fillStyle = '#555555';
                    ctx.fillRect(x, y, size, size);
                }

                // Add large blood stains on bricks
                for (let i = 0; i < 30; i++) {
                    const x = Math.floor(Math.random() * cols) * pixelSize;
                    const y = Math.floor(Math.random() * rows) * pixelSize;
                    const size = (3 + Math.floor(Math.random() * 6)) * pixelSize;
                    
                    const bloodColor = Math.random() > 0.7 ? '#330000' : 
                                     Math.random() > 0.5 ? '#660000' : '#990000';
                    ctx.fillStyle = bloodColor;
                    
                    for (let dy = 0; dy < size; dy++) {
                        for (let dx = 0; dx < size; dx++) {
                            if (Math.random() > 0.4) {
                                ctx.globalAlpha = 0.7 + Math.random() * 0.3;
                                ctx.fillRect(x + dx, y + dy, 1, 1);
                            }
                        }
                    }
                    
                    if (Math.random() > 0.5) {
                        const dripCount = 2 + Math.floor(Math.random() * 4);
                        for (let d = 0; d < dripCount; d++) {
                            const dripLength = 3 + Math.floor(Math.random() * 5);
                            const dripWidth = 1 + Math.floor(Math.random() * 2);
                            
                            ctx.fillStyle = bloodColor;
                            for (let l = 0; l < dripLength; l++) {
                                const offset = Math.floor(Math.random() * 3) - 1;
                                ctx.fillRect(
                                    x + size/2 + offset - dripWidth/2, 
                                    y + size + l, 
                                    dripWidth, 
                                    1
                                );
                            }
                        }
                    }
                    ctx.globalAlpha = 1.0;
                }

                // Add larger gruesome blood stains
                for (let i = 0; i < 50; i++) {
                    const x = Math.floor(Math.random() * cols) * pixelSize;
                    const y = Math.floor(Math.random() * rows) * pixelSize;
                    const size = (4 + Math.floor(Math.random() * 8)) * pixelSize;
                    
                    const bloodShade = Math.random() > 0.7 ? '#330000' : 
                                     Math.random() > 0.5 ? '#660000' : '#990000';
                    ctx.fillStyle = bloodShade;
                    
                    for (let dy = 0; dy < size; dy++) {
                        for (let dx = 0; dx < size; dx++) {
                            if (Math.random() > 0.3) {
                                ctx.globalAlpha = 0.7 + Math.random() * 0.3;
                                ctx.fillRect(x + dx, y + dy, 1, 1);
                            }
                        }
                    }
                    ctx.globalAlpha = 1.0;
                    
                    if (Math.random() > 0.5) {
                        const dripCount = 3 + Math.floor(Math.random() * 5);
                        for (let d = 0; d < dripCount; d++) {
                            const dripLength = 2 + Math.floor(Math.random() * 8);
                            const dripWidth = 1 + Math.floor(Math.random() * 2);
                            
                            ctx.fillStyle = bloodShade;
                            for (let l = 0; l < dripLength; l++) {
                                const offset = Math.floor(Math.random() * 3) - 1;
                                ctx.fillRect(
                                    x + size/2 + offset - dripWidth/2, 
                                    y + size + l, 
                                    dripWidth, 
                                    1
                                );
                            }
                        }
                    }
                }
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(16, 16);
                texture.magFilter = THREE.NearestFilter;
                texture.minFilter = THREE.NearestFilter;
                
                return new THREE.Mesh(
                    new THREE.PlaneGeometry(150, 150),
                    new THREE.MeshStandardMaterial({ 
                        map: texture,
                        side: THREE.DoubleSide
                    })
                );
            }

            // Instructions button functionality
            document.getElementById('instructions-button').addEventListener('click', function() {
                document.getElementById('main-menu').classList.add('hidden');
                document.getElementById('instructions-modal').classList.remove('hidden');
            });

            // Graphics button functionality
            document.getElementById('graphics-button').addEventListener('click', function() {
                document.getElementById('main-menu').classList.add('hidden');
                document.getElementById('graphics-modal').classList.remove('hidden');
            });

            // Close graphics modal
            document.getElementById('close-graphics').addEventListener('click', function() {
                document.getElementById('graphics-modal').classList.add('hidden');
                document.getElementById('main-menu').classList.remove('hidden');
            });

            document.getElementById('close-settings').addEventListener('click', function() {
                document.getElementById('settings-modal').classList.add('hidden');
                document.getElementById('main-menu').classList.remove('hidden');
            });

            document.getElementById('close-instructions').addEventListener('click', function() {
                document.getElementById('instructions-modal').classList.add('hidden');
                document.getElementById('main-menu').classList.remove('hidden');
            });

            document.getElementById('close-history').addEventListener('click', function() {
                document.getElementById('history-modal').classList.add('hidden');
                document.getElementById('main-menu').classList.remove('hidden');
                document.getElementById('container').classList.add('hidden');
                document.getElementById('crosshair').classList.add('hidden');
                document.getElementById('timer').classList.add('hidden');
            });
            const startButton = document.getElementById('start-button');
            const mainMenu = document.getElementById('main-menu');
            const container = document.getElementById('container');
            const crosshair = document.getElementById('crosshair');
			const bgMusic = document.getElementById('bg-music'); // <<< ADAUGAT
            
            startButton.addEventListener('click', function() {
                mainMenu.classList.add('hidden');
                const loadingScreen = document.getElementById('loading-screen');
                loadingScreen.classList.remove('hidden');
                
                // Create animated particles for loading screen
                createLoadingParticles();
                
                // Animate loading bar with percentage
                const loadingBar = document.getElementById('loading-bar');
                const percentageText = document.getElementById('loading-percentage');
                let width = 0;
                const interval = setInterval(() => {
                    width += 1;
                    loadingBar.style.width = `${width}%`;
                    percentageText.textContent = `${width}%`;
                    
                    // Add subtle glitch effects at certain percentages
                    if (width % 25 === 0) {
                        const glitchText = document.querySelector('.glitch-text');
                        glitchText.style.animation = 'none';
                        setTimeout(() => {
                            glitchText.style.animation = 'text-glitch 20s infinite';
                        }, 10);
                    }
                    
                    if (width >= 100) {
                        clearInterval(interval);
                        // Final animation before hiding
                        loadingScreen.style.opacity = '0';
                        loadingScreen.style.transition = 'opacity 0.5s ease-out';
                        
                        setTimeout(() => {
                            loadingScreen.classList.add('hidden');
                            loadingScreen.style.opacity = '1';
                            container.classList.remove('hidden');
                            crosshair.classList.remove('hidden');
                            
                            // Start music
                            bgMusic.volume = 0.5;
                            bgMusic.play().catch(() => {
                                console.log("Autoplay blocked, trebuie click ca să pornească.");
                            });
                            
                            // Initialize game after loading
                            setTimeout(initializeGame, 100);
                        }, 500);
                    }
                }, 45); // 4.5 seconds total (100% / 45ms)
            });
            
            // Create enhanced creepy particles for the background effect
            createSinisterParticles();
        });

        // Create animated particles for loading screen
        function createLoadingParticles() {
            const container = document.querySelector('.particles-container');
            container.innerHTML = '';
            
            for (let i = 0; i < 30; i++) {
                const particle = document.createElement('div');
                particle.className = 'absolute rounded-full animate-pulse';
                
                // Random size and position
                const size = Math.random() * 4 + 1;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.top = `${Math.random() * 100}%`;
                
                // Red color variations
                const colors = ['#ff0000', '#cc0000', '#990000', '#660000'];
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                particle.style.opacity = Math.random() * 0.3 + 0.1;
                
                // Add floating animation
                particle.style.animation = `float ${Math.random() * 6 + 4}s infinite ease-in-out`;
                particle.style.animationDelay = `${Math.random() * 2}s`;
                
                container.appendChild(particle);
            }

            // Add CSS for floating animation if not exists
            if (!document.querySelector('#loading-particles-animation')) {
                const style = document.createElement('style');
                style.id = 'loading-particles-animation';
                style.textContent = `
                    @keyframes float {
                        0%, 100% { 
                            transform: translate(0, 0) scale(1); 
                            opacity: ${Math.random() * 0.3 + 0.1};
                        }
                        50% { 
                            transform: translate(${Math.random() * 40 - 20}px, ${Math.random() * 40 - 20}px) scale(${Math.random() + 0.5});
                            opacity: ${Math.random() * 0.2 + 0.05};
                        }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        function createSinisterParticles() {
            const effectContainer = document.getElementById('sinister-effect');
            const colors = ['#ff0000', '#990000', '#660000', '#330000'];
            
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.style.position = 'absolute';
                particle.style.width = Math.random() * 4 + 1 + 'px';
                particle.style.height = particle.style.width;
                particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                particle.style.borderRadius = '50%';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.opacity = Math.random() * 0.5 + 0.1;
                particle.style.animation = `float ${Math.random() * 10 + 5}s infinite alternate ease-in-out`;
                
                // Add floating animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes float {
                        0% { transform: translate(0, 0) scale(1); opacity: ${Math.random() * 0.5 + 0.1}; }
                        100% { transform: translate(${Math.random() * 100 - 50}px, ${Math.random() * 100 - 50}px) scale(${Math.random() + 0.5}); opacity: ${Math.random() * 0.3}; }
                    }
                `;
                document.head.appendChild(style);
                
                effectContainer.appendChild(particle);
            }

            // Start glitch effect
            startGlitchEffect();
        }

        function startGlitchEffect() {
            const glitchOverlay = document.getElementById('glitch-overlay');
            const glitchLines = document.getElementById('glitch-lines');
            
            function triggerGlitch() {
                // Random timing between glitches (3-8 seconds)
                const nextGlitch = 3000 + Math.random() * 5000;
                
                // Random duration of glitch (100-300ms)
                const glitchDuration = 100 + Math.random() * 200;
                
                // Trigger the glitch
                glitchOverlay.style.animation = 'none';
                glitchLines.style.animation = 'none';
                
                setTimeout(() => {
                    // Add red tint overlay glitch
                    glitchOverlay.style.background = `linear-gradient(45deg, 
                        rgba(255, 0, 0, ${0.1 + Math.random() * 0.2}) 0%, 
                        rgba(0, 0, 0, 0) 50%, 
                        rgba(255, 0, 0, ${0.1 + Math.random() * 0.2}) 100%)`;
                    glitchOverlay.style.opacity = '0.3';
                    glitchOverlay.style.animation = `glitch-effect ${glitchDuration}ms forwards`;
                    
                    // Add scan lines effect
                    glitchLines.style.opacity = '0.2';
                    glitchLines.style.animation = `glitch-lines ${glitchDuration}ms forwards`;
                    
                    // Randomly shift text elements
                    const glitchTexts = document.querySelectorAll('.glitch-text');
                    glitchTexts.forEach(text => {
                        text.style.animation = 'none';
                        setTimeout(() => {
                            text.style.animation = `text-glitch ${glitchDuration}ms forwards`;
                        }, 10);
                    });
                    
                    // Reset after glitch duration
                    setTimeout(() => {
                        glitchOverlay.style.opacity = '0';
                        glitchLines.style.opacity = '0';
                    }, glitchDuration);
                    
                    // Schedule next glitch
                    setTimeout(triggerGlitch, nextGlitch);
                }, 10);
            }
            
            // Start the glitch cycle
            setTimeout(triggerGlitch, 2000);
        }

        // Initialize Three.js scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.FogExp2(0x330000, 0.05); // Reddish fog
        
        // Set up first-person camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1, 0);
        
        // Movement variables
        const moveSpeed = 0.05; // Slower movement
        const sprintSpeed = 0.09; // Faster sprint speed
        const rotSpeed = 0.003;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let sprinting = false;
        let flashlightOn = true; // Track flashlight state
        let yaw = 0;
        let pitch = 0;
		// Sunet pași
const footstepSound = document.getElementById('footstep');
let lastStepTime = 0;
        let canMove = true;
        let pointerLocked = false;
        let headBobTimer = 0;
        const headBobSpeed = 0.2;
        const sprintHeadBobSpeed = 0.3;
        const headBobAmount = 0.05;
        const walls = [];
        
        // Sprint cooldown system
        let sprintTimer = 0;
        let sprintCooldown = 0;
        const maxSprintTime = 12000; // 12 seconds in milliseconds
        const cooldownTime = 30000; // 30 seconds cooldown
        let isSprintOnCooldown = false;
        
        // Set up renderer with improved shadow quality at 720p resolution
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance"
        });
        const container = document.getElementById('container');
        // Set fixed 720p resolution (854x480)
        renderer.setSize(854, 480);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.shadowMap.autoUpdate = true;
        renderer.shadowMap.needsUpdate = true;
        renderer.shadowMap.width = 256;  // Reduced resolution to 256 pixels
        renderer.shadowMap.height = 256;
        renderer.shadowMap.soft = true;
        container.appendChild(renderer.domElement);
        
        // SSAO Effect
        const ssaoShader = {
            uniforms: {
                tDiffuse: { value: null },
                tDepth: { value: null },
                cameraNear: { value: camera.near },
                cameraFar: { value: camera.far },
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                cameraProjectionMatrix: { value: camera.projectionMatrix },
                cameraInverseProjectionMatrix: { value: camera.projectionMatrixInverse },
                kernelRadius: { value: 32 },
                minDistance: { value: 0.005 },
                maxDistance: { value: 0.05 },
                intensity: { value: 2.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                #include <packing>
                
                uniform sampler2D tDiffuse;
                uniform sampler2D tDepth;
                uniform float cameraNear;
                uniform float cameraFar;
                uniform vec2 resolution;
                uniform mat4 cameraProjectionMatrix;
                uniform mat4 cameraInverseProjectionMatrix;
                uniform float kernelRadius;
                uniform float minDistance;
                uniform float maxDistance;
                uniform float intensity;
                
                varying vec2 vUv;
                
                float getDepth(const in vec2 screenPosition) {
                    return texture2D(tDepth, screenPosition).x;
                }
                
                float getLinearDepth(const in vec2 screenPosition) {
                    float depth = getDepth(screenPosition);
                    return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
                }
                
                vec3 getViewPosition(const in vec2 screenPosition) {
                    float depth = getDepth(screenPosition);
                    vec2 clipXY = screenPosition * 2.0 - 1.0;
                    vec4 clipPosition = vec4(clipXY, depth, 1.0);
                    vec4 viewPosition = cameraInverseProjectionMatrix * clipPosition;
                    return viewPosition.xyz / viewPosition.w;
                }
                
                void main() {
                    vec2 texelSize = vec2(1.0) / resolution;
                    vec3 viewPosition = getViewPosition(vUv);
                    vec3 viewNormal = normalize(cross(dFdx(viewPosition), dFdy(viewPosition)));
                    
                    // Generate random kernel rotations
                    vec2 noiseScale = vec2(resolution.x / 4.0, resolution.y / 4.0);
                    vec3 random = vec3(0.0);
                    random.x = fract(sin(dot(vUv, vec2(12.9898, 78.233))) * 43758.5453);
                    random.y = fract(sin(dot(vUv, vec2(78.233, 12.9898))) * 43758.5453);
                    random.z = fract(sin(dot(vUv, vec2(12.9898, 78.233 + random.x))) * 43758.5453);
                    
                    float occlusion = 0.0;
                    float radius = kernelRadius * (1.0 - random.z);
                    
                    for (int i = 0; i < 16; i++) {
                        vec2 kernel = vec2(
                            sin(float(i) * 1.41) * radius,
                            cos(float(i) * 1.41) * radius
                        ) * texelSize;
                        
                        kernel = reflect(kernel, random.xy);
                        
                        vec2 sampleUV = vUv + kernel;
                        vec3 samplePosition = getViewPosition(sampleUV);
                        vec3 sampleVector = normalize(samplePosition - viewPosition);
                        
                        float sampleDepth = getLinearDepth(sampleUV);
                        float rangeCheck = smoothstep(0.0, 1.0, maxDistance / abs(viewPosition.z - sampleDepth));
                        occlusion += max(0.0, dot(viewNormal, sampleVector) - minDistance) * rangeCheck;
                    }
                    
                    occlusion = 1.0 - (occlusion / 16.0) * intensity;
                    
                    vec4 color = texture2D(tDiffuse, vUv);
                    gl_FragColor = vec4(color.rgb * occlusion, color.a);
                }
            `
        };

        // Create VHS effect with depth blur
        const vhsShader = {
            uniforms: {
                tDiffuse: { value: null },
                tDepth: { value: null },
                time: { value: 0 },
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                cameraNear: { value: camera.near },
                cameraFar: { value: camera.far }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform sampler2D tDepth;
                uniform float time;
                uniform vec2 resolution;
                uniform float cameraNear;
                uniform float cameraFar;
                varying vec2 vUv;

                // Random and noise functions for VHS effect
                float rand(vec2 co) {
                    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
                }

                // Convert depth buffer value to linear depth
                float linearizeDepth(float depth) {
                    return (2.0 * cameraNear) / (cameraFar + cameraNear - depth * (cameraFar - cameraNear));
                }

                void main() {
                    // Fisheye distortion
                    vec2 center = vec2(0.5, 0.5);
                    vec2 uv = vUv - center;
                    float dist = length(uv);
                    float fisheyeStrength = 0.5; // Adjust for stronger/weaker fisheye effect
                    
                    // Apply fisheye distortion
                    vec2 distortedUv = uv * (1.0 - fisheyeStrength * dist * dist);
                    distortedUv += center;
                    
                    // Time-based effects
                    float timeFactor = time * 0.5;
                    
                    // Get depth value and calculate blur amount based on distance
                    float depth = texture2D(tDepth, distortedUv).r;
                    float linearDepth = linearizeDepth(depth);
                    float blurAmount = clamp(linearDepth * 2.0, 0.0, 1.0); // More blur for distant objects
                    
                    // VHS noise
                    float noise = rand(distortedUv + mod(timeFactor, 100.0));
                    noise = pow(noise, 2.0) * 0.1;
                    
                    // Scan lines
                    float scanLine = sin(distortedUv.y * resolution.y * 0.7 + timeFactor * 10.0) * 0.02;
                    
                    // Color channel offset (VHS tracking error effect)
                    vec2 offset = vec2(0.002 * sin(timeFactor * 0.7), 0.002 * cos(timeFactor * 0.8));
                    
                    // Apply depth-based blur
                    vec3 color = vec3(0.0);
                    float total = 0.0;
                    int blurSamples = int(blurAmount * 10.0) + 1;
                    
                    for (int x = -blurSamples; x <= blurSamples; x++) {
                        for (int y = -blurSamples; y <= blurSamples; y++) {
                            vec2 sampleOffset = vec2(x, y) * (0.002 + blurAmount * 0.01) / float(blurSamples);
                            vec2 sampleUV = distortedUv + sampleOffset;
                            
                            float r = texture2D(tDiffuse, sampleUV + offset).r;
                            float g = texture2D(tDiffuse, sampleUV).g;
                            float b = texture2D(tDiffuse, sampleUV - offset).b;
                            
                            float weight = 1.0 - length(sampleOffset) / (float(blurSamples) * 0.01);
                            color += vec3(r, g, b) * weight;
                            total += weight;
                        }
                    }
                    
                    color /= total;
                    
                    // Combine with noise and scanlines
                    color += noise * 0.8;
                    color += scanLine * 1.2;
                    
                    // Increase contrast and saturation
                    color = mix(color, vec3(dot(color, vec3(0.299, 0.587, 0.114))), 0.05);
                    color = color * 1.2 - 0.1;
                    color = clamp(color, 0.0, 1.0);
                    
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        };
        
        // Create post-processing scene
        const postScene = new THREE.Scene();
        const postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const postMaterial = new THREE.ShaderMaterial({
            uniforms: vhsShader.uniforms,
            vertexShader: vhsShader.vertexShader,
            fragmentShader: vhsShader.fragmentShader
        });
        const postPlane = new THREE.PlaneGeometry(2, 2);
        const postQuad = new THREE.Mesh(postPlane, postMaterial);
        postScene.add(postQuad);
        
        // Create depth buffer
        const depthTexture = new THREE.DepthTexture();
        depthTexture.type = THREE.UnsignedShortType;
        
        // Create render targets for post-processing
        const renderTarget = new THREE.WebGLRenderTarget(
            window.innerWidth,
            window.innerHeight,
            { 
                minFilter: THREE.LinearFilter,
                magFilter: THREE.NearestFilter,
                depthTexture: depthTexture,
                depthBuffer: true
            }
        );
        
        // Create pixelated pine tree texture
        function createPineTreeTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Trunk (brown)
            ctx.fillStyle = '#5C4033';
            ctx.fillRect(12, 32, 8, 32);
            
            // Pine needles (dark green)
            ctx.fillStyle = '#0A5F38';
            
            // Bottom layer
            ctx.beginPath();
            ctx.moveTo(16, 0);
            ctx.lineTo(0, 32);
            ctx.lineTo(32, 32);
            ctx.closePath();
            ctx.fill();
            
            // Middle layer
            ctx.beginPath();
            ctx.moveTo(16, 8);
            ctx.lineTo(4, 32);
            ctx.lineTo(28, 32);
            ctx.closePath();
            ctx.fill();
            
            // Top layer
            ctx.beginPath();
            ctx.moveTo(16, 16);
            ctx.lineTo(8, 32);
            ctx.lineTo(24, 32);
            ctx.closePath();
            ctx.fill();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }
        
        // Much larger maze layout (1 = wall, 0 = path)
        const mazeLayout = [
           [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1],
[1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,1,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];
        
        // Create pixelated concrete texture in 720p
        function createConcreteTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1280;
            canvas.height = 720;
            const ctx = canvas.getContext('2d');
            
            // Base gray color
            ctx.fillStyle = '#7D7D7D';
            ctx.fillRect(0, 0, 1920, 1080);
            
            // Create pixelated concrete pattern
            const pixelSize = 60; // Larger pixels for 1080p
            for (let y = 0; y < 1080; y += pixelSize) {
                for (let x = 0; x < 1920; x += pixelSize) {
                    const shade = 100 + Math.random() * 40;
                    ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
                    ctx.fillRect(x, y, pixelSize, pixelSize);
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 1);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        // Create pixelated brick texture for walls in 720p
        function createEnhancedConcreteTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1280;
            canvas.height = 720;
            const ctx = canvas.getContext('2d');
            
            // Brick colors - reddish brown palette
            const brickColors = [
                '#8B3A3A', '#7A2929', '#6B2424', '#5C1F1F', '#4D1A1A'
            ];
            
            // Mortar color
            const mortarColor = '#3A2A1E';
            
            // Scale brick dimensions for 720p
            const brickWidth = 320;
            const brickHeight = 80;
            const mortarThickness = 16;
            
            // Fill with mortar color first
            ctx.fillStyle = mortarColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw bricks in staggered pattern
            for (let y = 0; y < canvas.height; y += brickHeight + mortarThickness) {
                const offset = (y / (brickHeight + mortarThickness)) % 2 === 0 ? 0 : brickWidth / 2;
                
                for (let x = -offset; x < canvas.width; x += brickWidth + mortarThickness) {
                    // Random brick color variation
                    const colorVar = Math.floor(Math.random() * brickColors.length);
                    ctx.fillStyle = brickColors[colorVar];
                    
                    // Add some pixelated texture to each brick
                    for (let by = 0; by < brickHeight; by += 8) {
                        for (let bx = 0; bx < brickWidth; bx += 8) {
                            const shade = Math.random() > 0.8 ? -10 : Math.random() > 0.6 ? 10 : 0;
                            const r = parseInt(ctx.fillStyle.substr(1, 2), 16) + shade;
                            const g = parseInt(ctx.fillStyle.substr(3, 2), 16) + shade;
                            const b = parseInt(ctx.fillStyle.substr(5, 2), 16) + shade;
                            ctx.fillStyle = `rgb(${Math.max(0, Math.min(255, r))}, 
                                                ${Math.max(0, Math.min(255, g))}, 
                                                ${Math.max(0, Math.min(255, b))})`;
                            ctx.fillRect(
                                x + bx + mortarThickness, 
                                y + by + mortarThickness, 
                                8, 8
                            );
                        }
                    }
                }
            }
            
            // Add some pixelated wear and tear
            for (let i = 0; i < 200; i++) {
                const x = Math.floor(Math.random() * canvas.width);
                const y = Math.floor(Math.random() * canvas.height);
                const size = 4 + Math.floor(Math.random() * 6);
                
                // Darker or lighter patches randomly
                if (Math.random() > 0.5) {
                    ctx.fillStyle = '#5C4033'; // Darker
                } else {
                    ctx.fillStyle = '#A37B6D'; // Lighter
                }
                
                // Draw pixelated damage
                for (let dy = 0; dy < size; dy++) {
                    for (let dx = 0; dx < size; dx++) {
                        if (Math.random() > 0.3) {
                            ctx.fillRect(x + dx, y + dy, 1, 1);
                        }
                    }
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 1); // Adjust repeat for 1080p
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        // Game difficulty and timer
        let gameTime = 300; // Default to Hard (5 minutes)
        let gameTimer;
        let selectedDifficulty = 'hard';
        
        function updateTimer() {
            gameTime--;
            const minutes = Math.floor(gameTime / 60).toString().padStart(2, '0');
            const seconds = (gameTime % 60).toString().padStart(2, '0');
            document.querySelector('#timer .vhs-timer').textContent = `${minutes}:${seconds}`;
            
            if (gameTime <= 0) {
                clearInterval(gameTimer);
                showVictory();
            }
        }
        
        function showVictory() {
            canMove = false;
            document.exitPointerLock();
            
            // Create victory screen based on difficulty
            const victoryScreen = document.createElement('div');
            victoryScreen.className = 'fixed inset-0 z-[2000] flex items-center justify-center bg-black bg-opacity-90';
            
            switch(selectedDifficulty) {
                case 'easy':
                    victoryScreen.innerHTML = `
                        <div class="text-center p-8 bg-green-900 bg-opacity-70 border-2 border-green-600 rounded-lg">
                            <h2 class="text-4xl text-green-400 font-mono mb-4">ALPHA PROTOCOL COMPLETE</h2>
                            <p class="text-green-300 text-xl">Congratulations on surviving the maze!</p>
                            <p class="text-green-200 mt-4">Your basic training has been successful.</p>
                            <button onclick="location.reload()" class="mt-6 px-6 py-2 bg-green-600 text-white rounded">
                                RETURN TO MENU
                            </button>
                        </div>
                    `;
                    break;
                    
                case 'medium':
                    victoryScreen.innerHTML = `
                        <div class="text-center p-8 bg-blue-900 bg-opacity-70 border-2 border-blue-600 rounded-lg">
                            <h2 class="text-4xl text-blue-400 font-mono mb-4">BETA PROTOCOL SUCCESSFUL</h2>
                            <p class="text-blue-300 text-xl">You survived... for now.</p>
                            <p class="text-blue-200 mt-4 italic">"The maze remembers those who trespass..."</p>
                            <button onclick="location.reload()" class="mt-6 px-6 py-2 bg-blue-600 text-white rounded">
                                RETURN TO MENU
                            </button>
                        </div>
                    `;
                    break;
                    
                case 'hard':
                    // Use the existing history modal
                    document.getElementById('history-modal').classList.remove('hidden');
                    return;
                    
                case 'nightmare':
                    victoryScreen.innerHTML = `
                        <div class="relative w-full max-w-4xl bg-black border-4 border-red-600 p-8 pixel-corners">
                            <div class="vhs-scanline absolute inset-0 pointer-events-none"></div>
                            
                            <!-- Glitch effect overlay -->
                            <div class="absolute inset-0 glitch-overlay"></div>
                            
                            <h2 class="text-red-500 text-4xl mb-6 font-mono tracking-widest glitch-text" 
                                data-text="CLASSIFIED DOSSIER: THE BROOKVALE CLOWN">
                                CLASSIFIED DOSSIER: THE BROOKVALE CLOWN
                            </h2>
                            
                            <div class="text-red-400 font-mono text-sm leading-relaxed glitch-content">
                                <p class="mb-4">**IDENTITY**: Timothy "Smiles" Birch</p>
                                <p class="mb-4">**ORIGIN**: Born 1972, Brookvale Asylum patient #734</p>
                                <p class="mb-4">**HISTORY**: Subject exhibited violent tendencies from childhood. 
                                First incident at age 12 - maternal filicide. Institutionalized until the 
                                Brookvale Asylum fire of 1995.</p>
                                
                                <p class="mb-4">**ESCALE**: During the fire, subject escaped along with 23 other patients. 
                                While others were recaptured, Birch vanished into the surrounding woodlands.</p>
                                
                                <p class="mb-4">**TRANSFORMATION**: Living in isolation, subject developed an obsession with 
                                circus mythology and clown personas. Began crafting his signature porcelain 
                                mask from asylum dinnerware.</p>
                                
                                <p class="mb-4">**M.O.**: Targets lost travelers and hikers near former asylum grounds. 
                                Uses maze-like knowledge of the terrain to disorient victims before striking.</p>
                                
                                <p class="mb-4">**STATUS**: At large. Estimated 47 victims. Considered extremely dangerous - 
                                do not approach. If spotted, contact local authorities immediately.</p>
                            </div>
                            
                            <button onclick="location.reload()" class="mt-8 px-8 py-3 bg-red-600 text-white font-mono 
                                border-2 border-black hover:bg-red-800 transition-all">
                                DECLASSIFY AND EXIT
                            </button>
                        </div>
                    `;
                    
                    // Add glitch effects for expert mode
                    const style = document.createElement('style');
                    style.textContent = `
                        .glitch-overlay {
                            background: linear-gradient(45deg, 
                                rgba(255,0,0,0.1) 0%, 
                                transparent 50%, 
                                rgba(0,255,255,0.1) 100%);
                            animation: expert-glitch 0.2s infinite;
                            pointer-events: none;
                        }
                        
                        .glitch-content {
                            animation: text-glitch-expert 3s infinite;
                        }
                        
                        @keyframes expert-glitch {
                            0% { opacity: 0.1; transform: translate(0); }
                            25% { opacity: 0.3; transform: translate(-2px, 2px); }
                            50% { opacity: 0.2; transform: translate(2px, -2px); }
                            75% { opacity: 0.4; transform: translate(-1px, -1px); }
                            100% { opacity: 0.1; transform: translate(1px, 1px); }
                        }
                        
                        @keyframes text-glitch-expert {
                            0%, 100% { opacity: 1; }
                            2% { opacity: 0.8; transform: translateX(-1px); }
                            4% { opacity: 0.9; transform: translateX(1px); }
                            6% { opacity: 0.7; transform: translateX(-2px); }
                            8% { opacity: 1; transform: translateX(0); }
                            50% { opacity: 0.95; }
                            98% { opacity: 0.8; }
                        }
                    `;
                    document.head.appendChild(style);
                    break;
            }
            
            document.body.appendChild(victoryScreen);
        }
        
        function initializeGame() {
            document.getElementById('timer').classList.remove('hidden');
            
            // Set game time based on selected difficulty
            switch(selectedDifficulty) {
                case 'easy':
                    gameTime = 120; // 2 minutes
                    break;
                case 'medium':
                    gameTime = 180; // 3 minutes
                    break;
                case 'hard':
                    gameTime = 300; // 5 minutes
                    break;
                case 'nightmare':
                    gameTime = 480; // 8 minutes
                    break;
            }
            
            updateTimer();
            gameTimer = setInterval(updateTimer, 1000);
        const wallSpacing = 3.0;
        const wallMaterial = new THREE.MeshStandardMaterial({ 
            map: createEnhancedConcreteTexture(),
            roughness: 0.8,
            metalness: 0.05,
            bumpScale: 0.1,
            side: THREE.DoubleSide
        });
        
        // Create 3D maze walls from layout
        for (let z = 0; z < mazeLayout.length; z++) {
            for (let x = 0; x < mazeLayout[z].length; x++) {
                if (mazeLayout[z][x] === 1) {
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(3.1, 20, 3.1),
                        wallMaterial
                    );
                    
                    wall.position.set(
                        (x - mazeLayout[0].length/2) * wallSpacing, 
                        1.0,  // Adjusted Y position for taller walls
                        (z - mazeLayout.length/2) * wallSpacing
                    );
                    
                    wall.castShadow = true;
                    wall.receiveShadow = true;
                    scene.add(wall);
                    
                    // Add collision volume for walls
                    walls.push({
                        x: wall.position.x,
                        z: wall.position.z,
                        width: 2.8,
                        depth: 2.8
                    });
                }
            }
        }
        
        // Add goal area at the end of the maze
        const goalGeometry = new THREE.BoxGeometry(3, 0.2, 3);
        const goalMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x00ff00,
            emissive: 0x00ff00,
            emissiveIntensity: 0.3
        });
        const goal = new THREE.Mesh(goalGeometry, goalMaterial);
        goal.position.set(
            (mazeLayout[0].length - 2 - mazeLayout[0].length/2) * wallSpacing,
            0.1,
            (mazeLayout.length - 2 - mazeLayout.length/2) * wallSpacing
        );
        goal.receiveShadow = true;
        scene.add(goal);

        // Coin collection system for easy mode
        let coins = [];
        let collectedCoins = 0;
        const totalCoins = 4;
        
        // Create coin UI counter
        const coinCounter = document.createElement('div');
        coinCounter.id = 'coin-counter';
        coinCounter.style.position = 'fixed';
        coinCounter.style.top = '20px';
        coinCounter.style.left = '20px';
        coinCounter.style.color = '#ffd700';
        coinCounter.style.fontFamily = 'Courier New, monospace';
        coinCounter.style.fontSize = '24px';
        coinCounter.style.fontWeight = 'bold';
        coinCounter.style.textShadow = '2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000';
        coinCounter.style.zIndex = '1000';
        coinCounter.innerHTML = 'COINS: 0/4';
        coinCounter.classList.add('hidden');
        document.body.appendChild(coinCounter);

        function createCoin(x, z) {
            const coinGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32);
            const coinMaterial = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                emissive: 0xffdd44,
                emissiveIntensity: 1.2,
                metalness: 0.8,
                roughness: 0.2
            });
            
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.position.set(x, 1, z);
            coin.rotation.x = Math.PI / 2;
            coin.userData = { collected: false };
            
            // Add pulsing animation
            coin.userData.originalY = coin.position.y;
            coin.castShadow = true;
            coin.receiveShadow = true;
            
            // Add glowing point light to the coin
            const coinLight = new THREE.PointLight(0xffdd44, 1.5, 3);
            coinLight.position.set(0, 0, 0);
            coin.add(coinLight);
            
            scene.add(coin);
            coins.push(coin);
            return coin;
        }

        function placeCoins(coinCount) {
            // Clear existing coins
            coins.forEach(coin => scene.remove(coin));
            coins = [];
            collectedCoins = 0;
            coinCounter.innerHTML = `COINS: 0/${coinCount}`;
            
            // Get all valid path positions from the maze layout
            const validPositions = [];
            const wallSpacing = 3.0;
            
            for (let z = 0; z < mazeLayout.length; z++) {
                for (let x = 0; x < mazeLayout[z].length; x++) {
                    if (mazeLayout[z][x] === 0) { // Only path cells (not walls)
                        const worldX = (x - mazeLayout[0].length/2) * wallSpacing;
                        const worldZ = (z - mazeLayout.length/2) * wallSpacing;
                        validPositions.push({ x: worldX, z: worldZ });
                    }
                }
            }
            
            // Remove positions that are too close to start or goal
            const startPos = { x: 0, z: 0 }; // Player starts at center
            const goalPos = {
                x: (mazeLayout[0].length - 2 - mazeLayout[0].length/2) * wallSpacing,
                z: (mazeLayout.length - 2 - mazeLayout.length/2) * wallSpacing
            };
            
            const filteredPositions = validPositions.filter(pos => {
                const distToStart = Math.sqrt(
                    Math.pow(pos.x - startPos.x, 2) + 
                    Math.pow(pos.z - startPos.z, 2)
                );
                const distToGoal = Math.sqrt(
                    Math.pow(pos.x - goalPos.x, 2) + 
                    Math.pow(pos.z - goalPos.z, 2)
                );
                
                // Keep positions that are at least 5 units away from start and goal
                return distToStart > 5 && distToGoal > 5;
            });
            
            // Shuffle and take first coinCount positions
            const shuffled = filteredPositions.sort(() => 0.5 - Math.random());
            const selectedPositions = shuffled.slice(0, coinCount);
            
            // Create coins at selected positions
            selectedPositions.forEach(pos => {
                createCoin(pos.x, pos.z);
            });
        }

        function checkCoinCollision() {
            coins.forEach(coin => {
                if (!coin.userData.collected) {
                    const dx = camera.position.x - coin.position.x;
                    const dz = camera.position.z - coin.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance < 1.5) {
                        // Collect coin
                        coin.userData.collected = true;
                        scene.remove(coin);
                        collectedCoins++;
                        
                        // Update UI - use different totals based on difficulty
                        if (selectedDifficulty === 'easy') {
                            coinCounter.innerHTML = `COINS: ${collectedCoins}/4`;
                        } else if (selectedDifficulty === 'nightmare') {
                            coinCounter.innerHTML = `COINS: ${collectedCoins}/12`;
                        }
                        
                        // Play collection sound
                        const collectSound = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEAQB8AAEAfAAABAAgAAABMYXZmNTguODUAAABABgAIAAAAABgAZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA extremely short coin collection sound');
                        collectSound.volume = 0.3;
                        collectSound.play();
                    }
                }
            });
        }
        
        // Create blood texture with 256x256 resolution for 720p
        function createDirtTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;  // Reduced resolution for 720p
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Base dark brown color
            ctx.fillStyle = '#3A2A1E';
            ctx.fillRect(0, 0, 512, 512);
            
            // Create pixelated dirt pattern with adjusted pixel size
            const pixelSize = 2; // Adjusted for 256px resolution
            const cols = 256 / pixelSize;
            const rows = 256 / pixelSize;
            
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    // Vary the shades for natural look
                    const shade = 30 + Math.random() * 40;
                    const r = Math.max(0, Math.min(255, shade));
                    const g = Math.max(0, Math.min(255, shade - 10 + Math.random() * 10));
                    const b = Math.max(0, Math.min(255, shade - 15 + Math.random() * 5));
                    
                    ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                }
            }
            
            // Add some scattered darker patches for depth (reduced count)
            for (let i = 0; i < 20; i++) {
                const x = Math.floor(Math.random() * cols) * pixelSize;
                const y = Math.floor(Math.random() * rows) * pixelSize;
                const size = (1 + Math.floor(Math.random() * 4)) * pixelSize;
                
                ctx.fillStyle = '#2A1A0E';
                ctx.fillRect(x, y, size, size);
            }
            
            // Add some scattered lighter patches for highlights (reduced count)
            for (let i = 0; i < 10; i++) {
                const x = Math.floor(Math.random() * cols) * pixelSize;
                const y = Math.floor(Math.random() * rows) * pixelSize;
                const size = (1 + Math.floor(Math.random() * 3)) * pixelSize;
                
                ctx.fillStyle = '#4A3A2E';
                ctx.fillRect(x, y, size, size);
            }
            
            // Add some small rocks/stones (reduced count)
            for (let i = 0; i < 8; i++) {
                const x = Math.floor(Math.random() * cols) * pixelSize;
                const y = Math.floor(Math.random() * rows) * pixelSize;
                const size = (1 + Math.floor(Math.random() * 2)) * pixelSize;
                
                ctx.fillStyle = '#555555';
                ctx.fillRect(x, y, size, size);
            }

            // Add large blood stains on bricks (reduced count and size)
            for (let i = 0; i < 8; i++) {
                const x = Math.floor(Math.random() * cols) * pixelSize;
                const y = Math.floor(Math.random() * rows) * pixelSize;
                const size = (2 + Math.floor(Math.random() * 4)) * pixelSize;
                
                // Blood color variations
                const bloodColor = Math.random() > 0.7 ? '#330000' : 
                                 Math.random() > 0.5 ? '#660000' : '#990000';
                ctx.fillStyle = bloodColor;
                
                // Draw irregular blood splatter
                for (let dy = 0; dy < size; dy++) {
                    for (let dx = 0; dx < size; dx++) {
                        if (Math.random() > 0.4) {
                            ctx.globalAlpha = 0.7 + Math.random() * 0.3;
                            ctx.fillRect(x + dx, y + dy, 1, 1);
                        }
                    }
                }
                
                // Add blood drips
                if (Math.random() > 0.5) {
                    const dripCount = 1 + Math.floor(Math.random() * 3);
                    for (let d = 0; d < dripCount; d++) {
                        const dripLength = 2 + Math.floor(Math.random() * 3);
                        const dripWidth = 1;
                        
                        ctx.fillStyle = bloodColor;
                        for (let l = 0; l < dripLength; l++) {
                            const offset = Math.floor(Math.random() * 3) - 1;
                            ctx.fillRect(
                                x + size/2 + offset - dripWidth/2, 
                                y + size + l, 
                                dripWidth, 
                                1
                            );
                        }
                    }
                }
                ctx.globalAlpha = 1.0;
            }

            // Add larger gruesome blood stains (reduced count and size)
            for (let i = 0; i < 12; i++) {
                const x = Math.floor(Math.random() * cols) * pixelSize;
                const y = Math.floor(Math.random() * rows) * pixelSize;
                const size = (3 + Math.floor(Math.random() * 5)) * pixelSize;
                
                // Blood color variations from bright red to dark dried blood
                const bloodShade = Math.random() > 0.7 ? '#330000' : 
                                 Math.random() > 0.5 ? '#660000' : '#990000';
                ctx.fillStyle = bloodShade;
                
                // Draw irregular blood splatters
                for (let dy = 0; dy < size; dy++) {
                    for (let dx = 0; dx < size; dx++) {
                        if (Math.random() > 0.3) {
                            // Make some parts more transparent for a natural look
                            ctx.globalAlpha = 0.7 + Math.random() * 0.3;
                            ctx.fillRect(x + dx, y + dy, 1, 1);
                        }
                    }
                }
                ctx.globalAlpha = 1.0;
                
                // Add some blood drips around the stains
                if (Math.random() > 0.5) {
                    const dripCount = 2 + Math.floor(Math.random() * 3);
                    for (let d = 0; d < dripCount; d++) {
                        const dripLength = 1 + Math.floor(Math.random() * 4);
                        const dripWidth = 1;
                        
                        ctx.fillStyle = bloodShade;
                        for (let l = 0; l < dripLength; l++) {
                            const offset = Math.floor(Math.random() * 3) - 1;
                            ctx.fillRect(
                                x + size/2 + offset - dripWidth/2, 
                                y + size + l, 
                                dripWidth, 
                                1
                            );
                        }
                    }
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(16, 16);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        // Add larger floor with pixelated dirt texture
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(150, 150),  // Larger floor to accommodate spaced walls
            new THREE.MeshStandardMaterial({ 
                map: createDirtTexture(),
                side: THREE.DoubleSide
            })
        );
        floor.rotation.x = Math.PI / 2;
        floor.position.y = -0.5;
        floor.receiveShadow = true;
        // Enable custom depth material for floor
        floor.customDepthMaterial = new THREE.MeshDepthMaterial({
            depthPacking: THREE.RGBADepthPacking,
            map: floor.material.map,
            alphaTest: 0.1
        });
        scene.add(floor);

        // Add small stones scattered on the ground
        const stoneGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const stoneMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x777777,
            roughness: 0.8,
            metalness: 0.1
        });

        // Create multiple small stones
        for (let i = 0; i < 200; i++) {
            const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
            
            // Random position on the floor
            stone.position.set(
                Math.random() * 140 - 70,  // -70 to 70 range
                -0.4,  // Slightly above floor
                Math.random() * 140 - 70
            );
            
            // Random small rotation
            stone.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            
            // Random small scale variation
            const scale = 0.7 + Math.random() * 0.6;
            stone.scale.set(scale, scale, scale);
            
            stone.castShadow = true;
            stone.receiveShadow = true;
            // Better shadow rendering for stones
            stone.customDepthMaterial = new THREE.MeshDepthMaterial({
                depthPacking: THREE.RGBADepthPacking,
                alphaTest: 0.1
            });
            scene.add(stone);
        }
        
        // Add dim ambient lighting
        const ambientLight = new THREE.AmbientLight(0x110000); // Much darker reddish ambient light
        scene.add(ambientLight);
        
        // Add moon to the sky - centered above
        const moonGeometry = new THREE.SphereGeometry(5, 32, 32);
        const moonMaterial = new THREE.MeshStandardMaterial({
            color: 0xFFFFCC,
            emissive: 0xFFFF99,
            emissiveIntensity: 1.2,
            roughness: 0.7,
            metalness: 0.1
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        moon.position.set(0, 60, -40); // Centered, higher up
        scene.add(moon);

        // Add stars to the sky - closer and brighter
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({
            color: 0xFFFFFF,
            size: 0.4, // Larger size for brighter stars
            sizeAttenuation: true
        });
        
        const starsVertices = [];
        // Create 8000 stars in a closer sphere
        for (let i = 0; i < 8000; i++) {
            const radius = 30 + Math.random() * 50; // Closer stars
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);
            
            starsVertices.push(x, y, z);
        }
        
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        const starField = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(starField);
        
        // Add improved flashlight effect with better shadows - now centered like crosshair
        const flashlight = new THREE.SpotLight(0xffffff, 2.0, 30, Math.PI/6, 0.3, 1.5);
        flashlight.position.set(0, 0, 0); // Centered position (same as camera)
        flashlight.target.position.set(0, 0, -1);
        flashlight.castShadow = true;
        flashlight.shadow.mapSize.width = 256;  // Reduced to 256 pixels
        flashlight.shadow.mapSize.height = 256;
        flashlight.shadow.bias = -0.00005;  // Reduced bias for better accuracy
        flashlight.shadow.normalBias = 0.03; // Reduced normal bias
        flashlight.shadow.camera.near = 0.2;
        flashlight.shadow.camera.far = 45;
        flashlight.shadow.focus = 0.8;       // Better focus
        flashlight.shadow.radius = 2;        // Softer shadow edges
        
        // Spring arm variables for flashlight lag effect
        let flashlightTargetPosition = new THREE.Vector3();
        let flashlightTargetQuaternion = new THREE.Quaternion();
        const springFactor = 0.15; // Controls the amount of lag (0-1)
        
        // Add flashlight to scene instead of camera for independent movement
        scene.add(flashlight);
        scene.add(flashlight.target);
        scene.add(camera);
        
        // Add improved directional light with better shadow quality
        const dirLight = new THREE.DirectionalLight(0x660000, 0.6); // Slightly brighter
        dirLight.position.set(0, 15, 0); // Higher position for better coverage
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 256;  // Reduced to 256 pixels
        dirLight.shadow.mapSize.height = 256;
        dirLight.shadow.bias = -0.00005;  // Reduced bias
        dirLight.shadow.normalBias = 0.03; // Reduced normal bias
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 120;
        dirLight.shadow.camera.left = -40;
        dirLight.shadow.camera.right = 40;
        dirLight.shadow.camera.top = 40;
        dirLight.shadow.camera.bottom = -40;
        // Add slight blur to directional light shadows
        dirLight.shadow.radius = 1.5;
        scene.add(dirLight);
        
        // Add improved point lights with better shadow settings
        for (let i = 0; i < 5; i++) {
            const light = new THREE.PointLight(0x550000, 1.0, 6); // Slightly brighter and longer range
            light.position.set(
                Math.random() * 12 - 6,  // Wider distribution
                1.5,                     // Slightly higher
                Math.random() * 12 - 6
            );
            light.castShadow = true;
            light.shadow.mapSize.width = 256;  // Reduced to 256 pixels
            light.shadow.mapSize.height = 256;
            light.shadow.bias = -0.0001;
            light.shadow.normalBias = 0.04;
            light.shadow.camera.near = 0.1;
            light.shadow.camera.far = 8;
            scene.add(light);
            
            // Add small visible light source
            const lightBulb = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 8, 8),
                new THREE.MeshBasicMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.5
                })
            );
            lightBulb.position.copy(light.position);
            scene.add(lightBulb);
        }
        
        // Place coins if in easy mode or extreme mode
        if (selectedDifficulty === 'easy') {
            placeCoins(4);
            coinCounter.innerHTML = 'COINS: 0/4';
            coinCounter.classList.remove('hidden');
        } else if (selectedDifficulty === 'nightmare') {
            placeCoins(12);
            coinCounter.innerHTML = 'COINS: 0/12';
            coinCounter.classList.remove('hidden');
        } else {
            coinCounter.classList.add('hidden');
        }

        // Footstep sounds
        const footstepSounds = [];
        // Create multiple footstep sounds for variety
        const footstepUrls = [
            'https://assets.mixkit.co/sfx/preview/mixkit-footsteps-on-grass-1231.mp3',
            'https://assets.mixkit.co/sfx/preview/mixkit-footsteps-on-grass-1232.mp3',
            'https://assets.mixkit.co/sfx/preview/mixkit-footsteps-on-grass-1233.mp3',
            'https://assets.mixkit.co/sfx/preview/mixkit-footsteps-on-grass-1234.mp3'
        ];
        
        for (let i = 0; i < footstepUrls.length; i++) {
            const audio = new Audio(footstepUrls[i]);
            audio.volume = 0.4;
            footstepSounds.push(audio);
        }
        let lastFootstepTime = 0;
        let footstepIndex = 0;
        let isMoving = false;

        // Create terrifying completely black monster with multiple arms
        function createSlenderman() {
            const group = new THREE.Group();
            
            // Tall, unnaturally thin body - completely black
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.18, 0.25, 4.0, 12),
                new THREE.MeshStandardMaterial({ 
                    color: 0x000000, // Completely black
                    roughness: 0.95,
                    metalness: 0.05
                })
            );
            body.position.y = 2.0;
            
            // Featureless black head
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.22, 32, 32),
                new THREE.MeshStandardMaterial({ 
                    color: 0x000000, // Completely black
                    roughness: 0.9,
                    metalness: 0.1
                })
            );
            head.position.set(0, 3.7, 0.1);
            
            // Long, thin neck - black
            const neck = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.12, 0.5, 12),
                new THREE.MeshStandardMaterial({ color: 0x000000 }) // Black neck
            );
            neck.position.y = 3.2;
            
            // Create multiple arms function
            const createArm = (side, verticalOffset, horizontalOffset, lengthMultiplier = 1.0) => {
                const armGroup = new THREE.Group();
                
                // Upper arm
                const upperArm = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.07, 1.8 * lengthMultiplier, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x000000, // Completely black
                        roughness: 0.9
                    })
                );
                upperArm.position.y = -0.9 * lengthMultiplier;
                upperArm.rotation.z = side * Math.PI / 8;
                
                // Lower arm
                const lowerArm = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.04, 0.05, 1.6 * lengthMultiplier, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x000000, // Completely black
                        roughness: 0.9
                    })
                );
                lowerArm.position.y = -1.6 * lengthMultiplier;
                
                // Hand with creepy long fingers
                const hand = new THREE.Mesh(
                    new THREE.SphereGeometry(0.06, 16, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x000000, // Completely black
                        roughness: 0.8
                    })
                );
                hand.position.y = -2.1 * lengthMultiplier;
                
                // Add some long, creepy fingers
                for (let i = 0; i < 4; i++) {
                    const finger = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.01, 0.008, 0.4, 6),
                        new THREE.MeshStandardMaterial({ color: 0x000000 })
                    );
                    finger.position.set(
                        (i - 1.5) * 0.015,
                        -2.3 * lengthMultiplier,
                        0.04
                    );
                    finger.rotation.x = Math.PI / 4;
                    hand.add(finger);
                }
                
                lowerArm.add(hand);
                armGroup.add(upperArm);
                armGroup.add(lowerArm);
                armGroup.position.set(side * horizontalOffset, 2.2 + verticalOffset, 0);
                
                return armGroup;
            };
            
            // Add multiple arms (8 arms total for extra horror)
            const arms = [
                createArm(-1, 0, 0.35, 1.0),    // Left main arm
                createArm(1, 0, 0.35, 1.0),     // Right main arm
                createArm(-1, 0.4, 0.25, 0.8),  // Left upper arm
                createArm(1, 0.4, 0.25, 0.8),   // Right upper arm
                createArm(-1, -0.3, 0.45, 1.2), // Left lower arm (longer)
                createArm(1, -0.3, 0.45, 1.2),  // Right lower arm (longer)
                createArm(-1, 0.7, 0.15, 0.6),  // Left top arm
                createArm(1, 0.7, 0.15, 0.6)    // Right top arm
            ];
            
            // Add subtle, unsettling sway animation component
            group.userData = { 
                swayOffset: Math.random() * Math.PI * 2,
                armTimers: arms.map(() => Math.random() * Math.PI * 2)
            };
            
            group.add(body);
            group.add(neck);
            group.add(head);
            
            // Add all arms
            arms.forEach(arm => {
                group.add(arm);
            });
            
            return group;
        }

        const slenderman = createSlenderman();
        // Start Slenderman at a random position in the maze
        slenderman.position.set(
            Math.random() * 20 - 10,
            0,
            Math.random() * 20 - 10
        );
        scene.add(slenderman);

        // Slenderman movement parameters
        const slendermanSpeed = 0.01;
        let slendermanVisible = false;
        let slendermanAppearTimer = 0;
        let slendermanAppearTimerMax = 10; // Default 10 seconds between appearances
        
        // Handle window resize - maintain 720p aspect ratio
        window.addEventListener('resize', () => {
            const container = document.getElementById('container');
            // Maintain 16:9 aspect ratio for 720p
            const aspectRatio = 16/9;
            let width = container.clientWidth;
            let height = container.clientHeight;
            
            if (width / height > aspectRatio) {
                width = height * aspectRatio;
            } else {
                height = width / aspectRatio;
            }
            
            camera.aspect = aspectRatio;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            vhsShader.uniforms.resolution.value.set(width, height);
            ssaoShader.uniforms.resolution.value.set(width, height);
            renderTarget.setSize(width, height);
        });
        
        // Initial resize to set 16:9 aspect ratio
        window.dispatchEvent(new Event('resize'));
        
        // Check if player reached the goal
        function checkGoal() {
            const dx = camera.position.x - goal.position.x;
            const dz = camera.position.z - goal.position.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            return distance < 2;
        }
        
        // Movement controls
        document.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': moveForward = true; break;
                case 's': moveBackward = true; break;
                case 'a': moveLeft = true; break;
                case 'd': moveRight = true; break;
                case 'shift':
                    // Disable sprint in expert mode
                    if (selectedDifficulty !== 'nightmare') {
                        if (!isSprintOnCooldown && (moveForward || moveBackward || moveLeft || moveRight)) {
                            sprinting = true;
                        }
                    }
                    break;
                case 'f': 
                    flashlightOn = !flashlightOn;
                    flashlight.visible = flashlightOn;
                    break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': moveForward = false; break;
                case 's': moveBackward = false; break;
                case 'a': moveLeft = false; break;
                case 'd': moveRight = false; break;
                case 'shift':
                    sprinting = false;
                    break;
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (pointerLocked) {
                const movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;
                const movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;
                
                yaw -= movementX * rotSpeed;
                pitch -= movementY * rotSpeed;
                
                // Limit vertical look to avoid flipping
                pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
                
                // Reset camera rotation and apply yaw/pitch properly
                camera.rotation.set(pitch, yaw, 0, 'YXZ');
            }
        });
        
        // Professional Pixelated Sprint UI element
        const sprintBar = document.createElement('div');
        sprintBar.style.position = 'fixed';
        sprintBar.style.bottom = '30px';
        sprintBar.style.left = '30px';
        sprintBar.style.width = '200px';
        sprintBar.style.height = '24px';
        sprintBar.style.backgroundColor = '#0a0a0a';
        sprintBar.style.border = '3px solid #222';
        sprintBar.style.overflow = 'hidden';
        sprintBar.style.display = 'none';
        sprintBar.style.zIndex = '1000';
        sprintBar.style.boxShadow = '0 0 15px rgba(0,0,0,0.9), inset 0 0 10px rgba(0,0,0,0.7)';
        sprintBar.style.imageRendering = 'pixelated';
        
        // Create pixelated background pattern
        const bgPattern = document.createElement('div');
        bgPattern.style.position = 'absolute';
        bgPattern.style.top = '0';
        bgPattern.style.left = '0';
        bgPattern.style.width = '100%';
        bgPattern.style.height = '100%';
        bgPattern.style.background = 'linear-gradient(45deg, #1a1a1a 25%, #0f0f0f 25%, #0f0f0f 50%, #1a1a1a 50%, #1a1a1a 75%, #0f0f0f 75%, #0f0f0f)';
        bgPattern.style.backgroundSize = '8px 8px';
        bgPattern.style.opacity = '0.6';
        sprintBar.appendChild(bgPattern);
        
        const sprintFill = document.createElement('div');
        sprintFill.style.width = '100%';
        sprintFill.style.height = '100%';
        sprintFill.style.backgroundColor = '#1e7a1e';
        sprintFill.style.transition = 'width 0.1s ease-out';
        sprintFill.style.position = 'relative';
        sprintFill.style.overflow = 'hidden';
        
        // Add pixelated fill pattern
        const fillPattern = document.createElement('div');
        fillPattern.style.position = 'absolute';
        fillPattern.style.top = '0';
        fillPattern.style.left = '0';
        fillPattern.style.width = '100%';
        fillPattern.style.height = '100%';
        fillPattern.style.background = 'linear-gradient(45deg, #2a8c2a 25%, #1e7a1e 25%, #1e7a1e 50%, #2a8c2a 50%, #2a8c2a 75%, #1e7a1e 75%, #1e7a1e)';
        fillPattern.style.backgroundSize = '8px 8px';
        fillPattern.style.opacity = '0.8';
        sprintFill.appendChild(fillPattern);
        
        // Add pixelated border effect
        const pixelBorder = document.createElement('div');
        pixelBorder.style.position = 'absolute';
        pixelBorder.style.top = '0';
        pixelBorder.style.left = '0';
        pixelBorder.style.right = '0';
        pixelBorder.style.bottom = '0';
        pixelBorder.style.boxShadow = 'inset 0 0 0 2px #333, inset 2px 2px 0 2px #444, inset -2px -2px 0 2px #111';
        sprintBar.appendChild(pixelBorder);
        
        sprintBar.appendChild(sprintFill);
        
        // Add pixelated text label
        const sprintLabel = document.createElement('div');
        sprintLabel.style.position = 'absolute';
        sprintLabel.style.top = '-26px';
        sprintLabel.style.left = '0';
        sprintLabel.style.color = '#1e7a1e';
        sprintLabel.style.fontFamily = '"Courier New", monospace';
        sprintLabel.style.fontSize = '14px';
        sprintLabel.style.fontWeight = 'bold';
        sprintLabel.style.textShadow = '2px 2px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000';
        sprintLabel.style.letterSpacing = '2px';
        sprintLabel.style.textTransform = 'uppercase';
        sprintLabel.textContent = 'SPRINT';
        sprintBar.appendChild(sprintLabel);
        
        // Add cooldown indicator text
        const cooldownText = document.createElement('div');
        cooldownText.style.position = 'absolute';
        cooldownText.style.top = '-26px';
        cooldownText.style.right = '0';
        cooldownText.style.color = '#ff4444';
        cooldownText.style.fontFamily = '"Courier New", monospace';
        cooldownText.style.fontSize = '12px';
        cooldownText.style.fontWeight = 'bold';
        cooldownText.style.textShadow = '1px 1px 0 #000';
        cooldownText.textContent = 'COOLDOWN';
        cooldownText.style.display = 'none';
        sprintBar.appendChild(cooldownText);
        
        document.body.appendChild(sprintBar);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Handle sprint cooldown
            if (isSprintOnCooldown) {
                sprintCooldown -= 16; // Approximately 60fps
                if (sprintCooldown <= 0) {
                    isSprintOnCooldown = false;
                    sprintCooldown = 0;
                    sprintBar.style.display = 'none';
                } else {
                    sprintFill.style.width = `${(sprintCooldown / cooldownTime) * 100}%`;
                    sprintFill.style.backgroundColor = '#7a1e1e';
                    // Update cooldown pattern
                    const fillPattern = sprintFill.querySelector('div');
                    fillPattern.style.background = 'linear-gradient(45deg, #8c2a2a 25%, #7a1e1e 25%, #7a1e1e 50%, #8c2a2a 50%, #8c2a2a 75%, #7a1e1e 75%, #7a1e1e)';
                    fillPattern.style.backgroundSize = '8px 8px';
                    cooldownText.style.display = 'block';
                }
            }
            
            // Handle active sprint
            if (sprinting && !isSprintOnCooldown) {
                sprintTimer += 16;
                sprintBar.style.display = 'block';
                sprintFill.style.width = `${100 - (sprintTimer / maxSprintTime) * 100}%`;
                sprintFill.style.backgroundColor = '#1e7a1e';
                // Reset pattern to sprint style
                const fillPattern = sprintFill.querySelector('div');
                fillPattern.style.background = 'linear-gradient(45deg, #2a8c2a 25%, #1e7a1e 25%, #1e7a1e 50%, #2a8c2a 50%, #2a8c2a 75%, #1e7a1e 75%, #1e7a1e)';
                fillPattern.style.backgroundSize = '8px 8px';
                cooldownText.style.display = 'none';
                
                if (sprintTimer >= maxSprintTime) {
                    sprinting = false;
                    isSprintOnCooldown = true;
                    sprintCooldown = cooldownTime;
                    sprintTimer = 0;
                }
            } else if (!sprinting && sprintTimer > 0 && !isSprintOnCooldown) {
                // Gradually decrease sprint timer when not sprinting
                sprintTimer = Math.max(0, sprintTimer - 32);
                sprintFill.style.width = `${100 - (sprintTimer / maxSprintTime) * 100}%`;
                if (sprintTimer === 0) {
                    sprintBar.style.display = 'none';
                    cooldownText.style.display = 'none';
                }
            }
            
            // Update VHS shader time
            vhsShader.uniforms.time.value = performance.now() / 1000;
            
            // Spring arm effect for flashlight - lag behind camera movement
            flashlightTargetPosition.copy(camera.position);
            flashlightTargetQuaternion.copy(camera.quaternion);
            
            // Apply spring interpolation to position and rotation
            flashlight.position.lerp(flashlightTargetPosition, springFactor);
            flashlight.quaternion.slerp(flashlightTargetQuaternion, springFactor);
            
            // Update flashlight target to follow with the same lag
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(flashlight.quaternion);
            flashlight.target.position.copy(flashlight.position).add(direction);
            
            // Slenderman behavior
            slendermanAppearTimer += 0.01;
            
            // Make Slenderman appear/disappear periodically
            if (slendermanAppearTimer > slendermanAppearTimerMax) {
                slendermanVisible = !slendermanVisible;
                slendermanAppearTimer = 0;
                slenderman.visible = slendermanVisible;
                
                if (slendermanVisible) {
                    // Teleport Slenderman closer to player when appearing
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 5 + Math.random() * 5;
                    slenderman.position.set(
                        camera.position.x + Math.cos(angle) * distance,
                        0,
                        camera.position.z + Math.sin(angle) * distance
                    );
                }
            }
            
            // Make Slenderman follow player when visible with unsettling movement
            if (slendermanVisible) {
                const dx = camera.position.x - slenderman.position.x;
                const dz = camera.position.z - slenderman.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance > 2) {
                    // Move toward player with slightly erratic movement
                    slenderman.position.x += (dx / distance) * slendermanSpeed * (0.8 + Math.random() * 0.4);
                    slenderman.position.z += (dz / distance) * slendermanSpeed * (0.8 + Math.random() * 0.4);
                }
                
                // Make Slenderman always face the player with slight delay for creepiness
                const targetRotation = Math.atan2(dx, dz);
                slenderman.rotation.y = THREE.MathUtils.lerp(slenderman.rotation.y, targetRotation, 0.1);
                
                // Add subtle swaying motion to make it more unsettling
                const swayAmount = 0.03;
                slenderman.position.y += Math.sin(performance.now() * 0.002 + slenderman.userData.swayOffset) * swayAmount;
                
                // Animate the multiple arms for extra creepiness
                const arms = slenderman.children.filter(child => child.type === 'Group');
                arms.forEach((arm, index) => {
                    const timer = slenderman.userData.armTimers[index] || 0;
                    const armSpeed = 0.02 + Math.random() * 0.01;
                    const armSway = Math.sin(performance.now() * 0.001 + timer) * 0.2;
                    
                    // Rotate arms in unsettling ways
                    arm.rotation.x = armSway;
                    arm.rotation.z = Math.cos(performance.now() * 0.001 + timer) * 0.15;
                    
                    slenderman.userData.armTimers[index] = timer + armSpeed;
                });
                
                // Random flickering and distortion effects when Slenderman is close
                if (distance < 10) {
                    // More intense flickering as he gets closer
                    const flickerChance = 0.95 - (distance / 20);
                    if (Math.random() > flickerChance) {
                        flashlight.intensity = Math.random() * 0.3;
                        setTimeout(() => {
                            flashlight.intensity = 1;
                        }, 50 + Math.random() * 100);
                    }
                    
                    // Add screen distortion effect when very close
                    if (distance < 5 && Math.random() > 0.98) {
                        vhsShader.uniforms.time.value += 2; // Intensify VHS effect
                    }
                }
            }
            
            // Movement with collision detection
            if (canMove && pointerLocked) {
                const originalX = camera.position.x;
                const originalZ = camera.position.z;
                
                
                // Improved collision detection with walls
                const playerRadius = 0.3;
                for (const wall of walls) {
                    const wallLeft = wall.x - wall.width/2 - playerRadius;
                    const wallRight = wall.x + wall.width/2 + playerRadius;
                    const wallFront = wall.z - wall.depth/2 - playerRadius;
                    const wallBack = wall.z + wall.depth/2 + playerRadius;
                    
                    if (camera.position.x > wallLeft && 
                        camera.position.x < wallRight &&
                        camera.position.z > wallFront && 
                        camera.position.z < wallBack) {
                        // Find closest edge to push player back to
                        const dx1 = Math.abs(camera.position.x - wallLeft);
                        const dx2 = Math.abs(camera.position.x - wallRight);
                        const dz1 = Math.abs(camera.position.z - wallFront);
                        const dz2 = Math.abs(camera.position.z - wallBack);
                        
                        const minDist = Math.min(dx1, dx2, dz1, dz2);
                        
                        if (minDist === dx1) camera.position.x = wallLeft;
                        else if (minDist === dx2) camera.position.x = wallRight;
                        else if (minDist === dz1) camera.position.z = wallFront;
                        else camera.position.z = wallBack;
                        break;
                    }
                }
                
                // Head bobbing effect when moving
                if (moveForward || moveBackward || moveLeft || moveRight) {
                    const currentHeadBobSpeed = sprinting ? sprintHeadBobSpeed : headBobSpeed;
                    headBobTimer += currentHeadBobSpeed;
                    camera.position.y = 1 + Math.sin(headBobTimer) * headBobAmount;
					 // Sunet pași
                    const now = performance.now();
                    const stepInterval = sprinting ? 300 : 400; // Faster steps when sprinting
                    if (now - lastStepTime > stepInterval) {
                        footstepSound.currentTime = 0;
                        footstepSound.play();
                        lastStepTime = now;
                    }
                } else {
                    camera.position.y = 1;
                    headBobTimer = 0;
                }
                
                // Apply sprint speed
                const currentSpeed = sprinting ? sprintSpeed : moveSpeed;
                
                if (moveForward) {
                    camera.translateZ(-currentSpeed);
                }
                if (moveBackward) {
                    camera.translateZ(currentSpeed);
                }
                if (moveLeft) {
                    camera.translateX(-currentSpeed);
                }
                if (moveRight) {
                    camera.translateX(currentSpeed);
                }
            }
            
            // Random light flicker for horror effect
            if (Math.random() > 0.95) {
                const pointLights = scene.children.filter(child => child instanceof THREE.PointLight);
                if (pointLights.length > 0) {
                    const randomLight = pointLights[Math.floor(Math.random() * pointLights.length)];
                    randomLight.intensity = Math.random() * 0.5 + 0.5;
                }
            }

            // Animate coins with floating and rotation for easy and nightmare modes
            if (selectedDifficulty === 'easy' || selectedDifficulty === 'nightmare') {
                coins.forEach(coin => {
                    if (!coin.userData.collected) {
                        // Floating animation
                        coin.position.y = coin.userData.originalY + Math.sin(performance.now() * 0.002) * 0.2;
                        // Rotation animation
                        coin.rotation.z += 0.02;
                        
                        // Pulsing glow effect
                        const time = performance.now() * 0.002;
                        const intensity = 1.2 + Math.sin(time) * 0.3;
                        coin.material.emissiveIntensity = intensity;
                        
                        // Update coin light intensity
                        if (coin.children[0] && coin.children[0].isPointLight) {
                            coin.children[0].intensity = intensity * 1.2;
                        }
                    }
                });
                
                // Check for coin collisions
                checkCoinCollision();
            }
            
            // Check if Slenderman is too close (game over condition)
            if (slendermanVisible) {
                const dx = camera.position.x - slenderman.position.x;
                const dz = camera.position.z - slenderman.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance < 2) {
                    // Professional horror death screen with enhanced effects
                    const gameOverScreen = document.createElement('div');
                    gameOverScreen.className = 'fixed inset-0 z-[2000] flex flex-col items-center justify-center bg-black overflow-hidden death-screen';
                    gameOverScreen.innerHTML = `
                        <!-- Cinematic black bars -->
                        <div class="absolute top-0 left-0 w-full h-24 bg-black opacity-95 cinematic-bar"></div>
                        <div class="absolute bottom-0 left-0 w-full h-24 bg-black opacity-95 cinematic-bar"></div>
                        
                        <!-- Distorted film grain overlay -->
                        <div class="absolute inset-0 film-grain opacity-20"></div>
                        
                        <!-- Blood splatter overlay -->
                        <div class="absolute inset-0 blood-splatter-overlay"></div>
                        
                        <!-- Intense red vignette -->
                        <div class="absolute inset-0 red-vignette"></div>
                        
                        <!-- CRT scanlines overlay -->
                        <div class="absolute inset-0 crt-scanlines"></div>
                        
                        <!-- Main content -->
                        <div class="relative z-10 text-center transform perspective-1000 death-content">
                            <!-- Main title with enhanced horror styling -->
                            <div class="death-title-container relative mb-10">
                                <h1 class="death-title glitch-layers text-8xl md:text-9xl font-black text-white tracking-widest">
                                    <span class="death-layer death-text-1">TERMINATED</span>
                                    <span class="death-layer death-text-2">TERMINATED</span>
                                    <span class="death-layer death-text-3">TERMINATED</span>
                                    <span class="death-layer death-text-4">TERMINATED</span>
                                </h1>
                                <div class="death-title-shadow">TERMINATED</div>
                            </div>
                            
                            <!-- Subtitle with atmospheric message -->
                            <div class="text-red-300 text-xl md:text-2xl font-mono tracking-widest mb-12 opacity-90 glitch-subtitle">
                                SUBJECT #${Math.floor(1000 + Math.random() * 9000)} DECEASED
                            </div>
                            
                            <!-- Cooldown timer with professional styling -->
                            <div class="timer-container bg-black bg-opacity-80 p-8 border-2 border-red-800 rounded-xl relative mb-12">
                                <div class="absolute -inset-4 border border-red-600 opacity-50 rounded-xl"></div>
                                <div class="text-gray-400 text-sm font-mono tracking-widest mb-4 uppercase">
                                    SYSTEM REBOOT IN PROGRESS
                                </div>
                                <div class="text-red-500 text-5xl md:text-6xl font-mono font-bold digital-timer" id="cooldown-timer">10</div>
                                <div class="text-gray-500 text-xs font-mono mt-3 tracking-widest uppercase">
                                    SECONDS REMAINING
                                </div>
                                <div class="absolute bottom-2 left-0 right-0 h-1 bg-red-900 overflow-hidden">
                                    <div class="progress-bar h-full bg-red-600"></div>
                                </div>
                            </div>
                            
                            <!-- Atmospheric quote -->
                            <div class="mb-12 text-red-400 text-base font-mono tracking-widest max-w-2xl leading-relaxed quote-container">
                                <div class="quote-text">"THE MAZE CLAIMS ANOTHER SOUL. THE ENTITY'S HUNGER IS NEVER SATIATED."</div>
                                <div class="text-red-600 text-sm mt-2">- SECURITY LOG #${Math.floor(10000 + Math.random() * 90000)}</div>
                            </div>
                            
                            <!-- Status indicators -->
                            <div class="status-indicators flex justify-center space-x-6 mb-8">
                                <div class="status-item flex items-center">
                                    <div class="w-3 h-3 bg-red-500 rounded-full mr-2 animate-pulse status-indicator"></div>
                                    <div class="text-red-400 text-xs font-mono tracking-widest">SECURITY BREACH</div>
                                </div>
                                <div class="status-item flex items-center">
                                    <div class="w-3 h-3 bg-red-500 rounded-full mr-2 animate-pulse status-indicator" style="animation-delay: 0.3s"></div>
                                    <div class="text-red-400 text-xs font-mono tracking-widest">BIOSIGN LOST</div>
                                </div>
                            </div>
                            
                            <!-- System diagnostics -->
                            <div class="system-diagnostics bg-black bg-opacity-60 p-4 rounded-lg border border-red-900 max-w-md mx-auto">
                                <div class="text-red-500 text-xs font-mono mb-2 tracking-widest text-left">SYSTEM DIAGNOSTICS:</div>
                                <div class="text-red-400 text-xs font-mono space-y-1 text-left">
                                    <div class="flex justify-between"><span>HEARTBEAT:</span> <span class="text-red-600">NULL</span></div>
                                    <div class="flex justify-between"><span>NEURAL ACTIVITY:</span> <span class="text-red-600">0%</span></div>
                                    <div class="flex justify-between"><span>VITAL SIGNS:</span> <span class="text-red-600">TERMINATED</span></div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Emergency lighting effect -->
                        <div class="absolute inset-0 emergency-lights"></div>
                        
                        <!-- Audio element for death sound -->
                        <audio id="death-sound" preload="auto">
                            <source src="data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAADwADw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PD//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AAABQTEFNRTMuMTAwBKkAAAAAAAAAADUgJAObQgAADwAAA8C8Z0c8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//tUZAAP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAETEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV极简音效" type="audio/mpeg">
                        </audio>
                    `;
                    document.body.appendChild(gameOverScreen);
                    
                    // Add CSS for the professional death screen
                    const deathScreenStyles = document.createElement('style');
                    deathScreenStyles.textContent = `
                        .film-grain {
                            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><filter id="grain"><feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="3" stitchTiles="stitch"></feTurbulence></filter><rect width="100" height="100" filter="url(#grain)" opacity="0.3"></rect></svg>');
                            background-size: 200px;
                            mix-blend-mode: overlay;
                            pointer-events: none;
                        }
                        
                        .red-vignette {
                            background: radial-gradient(ellipse at center, rgba(0,0,0,0) 0%, rgba(0,0,0,0.8) 50%, rgba(139,0,0,0.9) 100%);
                            pointer-events: none;
                        }
                        
                        .death-title {
                            position: relative;
                            text-shadow: 0 0 30px rgba(255,0,0,0.8);
                        }
                        
                        .death-text-1 {
                            position: absolute;
                            top: 0;
                            left: 0;
                            width: 100%;
                            color: #ff0000;
                            clip-path: polygon(0 0, 100% 0, 100% 40%, 0 40%);
                            animation: text-flicker-1 3s infinite;
                        }
                        
                        .death-text-2 {
                            position: absolute;
                            top: 0;
                            left: 0;
                            width: 100%;
                            color: #990000;
                            clip-path: polygon(0 60%, 100% 60%, 100% 100%, 0 100%);
                            animation: text-flicker-2 4s infinite;
                        }
                        
                        .death-text-3 {
                            opacity: 0.9;
                            color: #330000;
                            position: relative;
                            z-index: -1;
                        }
                        
                        .timer-container {
                            box-shadow: 0 0 40px rgba(255,0,0,0.3),
                                       inset 0 0 20px rgba(0,0,0,0.5);
                            border: 1px solid rgba(255,0,0,0.3) !important;
                            animation: timer-glitch 2s infinite;
                        }
                        
                        .emergency-lights {
                            background: radial-gradient(circle at 20% 30%, rgba(255,0,0,0.1) 0%, transparent 50%),
                                      radial-gradient(circle at 80% 70%, rgba(139,0,0,0.1) 0%, transparent 50%);
                            animation: emergency-pulse 4s infinite;
                            pointer-events: none;
                        }
                        
                        @keyframes text-flicker-1 {
                            0%, 100% { opacity: 1; transform: translateY(0); }
                            25% { opacity: 0.8; transform: translateY(-2px); }
                            50% { opacity: 0.9; transform: translateY(1px); }
                            75% { opacity: 0.7; transform: translateY(-1px); }
                        }
                        
                        @keyframes text-flicker-2 {
                            0%, 100% { opacity: 1; transform: translateY(0); }
                            33% { opacity: 0.6; transform: translateY(2px); }
                            66% { opacity: 0.8; transform: translateY(-1px); }
                        }
                        
                        @keyframes timer-glitch {
                            0%, 100% { transform: translateX(0); }
                            5% { transform: translateX(-2px); }
                            10% { transform: translateX(2px); }
                            15% { transform: translateX(-1px); }
                            20% { transform: translateX(1px); }
                        }
                        
                        @keyframes emergency-pulse {
                            0%, 100% { opacity: 0.3; }
                            50% { opacity: 0.6; }
                        }
                        
                        .perspective-1000 {
                            perspective: 1000px;
                        }
                    `;
                    document.head.appendChild(deathScreenStyles);
                    
                    let cooldown = 5;
                    const cooldownInterval = setInterval(() => {
                        cooldown--;
                        document.getElementById('cooldown-timer').textContent = cooldown;
                        
                        // Add intense effect when timer is low
                        if (cooldown <= 3) {
                            document.getElementById('cooldown-timer').classList.add('text-red-500');
                            document.querySelector('.timer-container').style.animation = 'timer-pulse 0.5s infinite alternate';
                        }
                        
                        if (cooldown <= 0) {
                            clearInterval(cooldownInterval);
                            document.body.removeChild(gameOverScreen);
                            document.head.removeChild(deathScreenStyles);
                            
                            // Reset game state
                            camera.position.set(0, 1, 0);
                            camera.rotation.set(0, 0, 0);
                            yaw = 0;
                            pitch = 0;
                            
                            // Reset Slenderman
                            slenderman.position.set(
                                Math.random() * 20 - 10,
                                0,
                                Math.random() * 20 - 10
                            );
                            slendermanVisible = false;
                            slenderman.visible = false;
                            slendermanAppearTimer = 0;
                            
                            // Reset movement
                            moveForward = moveBackward = moveLeft = moveRight = false;
                            canMove = true;
                            
                            // Reset timer based on selected difficulty
                            switch(selectedDifficulty) {
                                case 'easy':
                                    gameTime = 120;
                                    break;
                                case 'medium':
                                    gameTime = 180;
                                    break;
                                case 'hard':
                                    gameTime = 300;
                                    break;
                                case 'nightmare':
                                    gameTime = 480;
                                    break;
                            }
                            updateTimer();
                            if (gameTimer) clearInterval(gameTimer);
                            gameTimer = setInterval(updateTimer, 1000);
                            
                            // Re-enable pointer lock
                            renderer.domElement.requestPointerLock();
                        }
                    }, 1000);
                    
                    // Stop movement
                    moveForward = moveBackward = moveLeft = moveRight = false;
                    canMove = false;
                    document.exitPointerLock();
                }
            }
            
            // Check if player reached the goal
            if (checkGoal()) {
                document.body.style.backgroundColor = 'green';
                setTimeout(() => {
                    document.body.style.backgroundColor = 'black';
                    camera.position.set(0, 1, 0);
                }, 1000);
            }
            
            // First render to render target
            renderer.setRenderTarget(renderTarget);
            renderer.render(scene, camera);
            
            // Then render with VHS shader
            renderer.setRenderTarget(null);
            vhsShader.uniforms.tDiffuse.value = renderTarget.texture;
            vhsShader.uniforms.cameraNear.value = camera.near;
            vhsShader.uniforms.cameraFar.value = camera.far;
            renderer.render(postScene, postCamera);
        }
        
        animate();
        }
        
        // Pointer lock controls
        renderer.domElement.requestPointerLock = renderer.domElement.requestPointerLock || 
                                               renderer.domElement.mozRequestPointerLock ||
                                               renderer.domElement.webkitRequestPointerLock;
        
        document.addEventListener('pointerlockchange', lockChangeAlert, false);
        document.addEventListener('mozpointerlockchange', lockChangeAlert, false);
        document.addEventListener('webkitpointerlockchange', lockChangeAlert, false);
        
        function lockChangeAlert() {
            if (document.pointerLockElement === renderer.domElement ||
                document.mozPointerLockElement === renderer.domElement ||
                document.webkitPointerLockElement === renderer.domElement) {
                pointerLocked = true;
                canMove = true;
            } else {
                pointerLocked = false;
                canMove = false;
            }
        }
        
        renderer.domElement.onclick = function() {
            if (!pointerLocked) {
                renderer.domElement.requestPointerLock();
            }
        };
    </script>
<p style="border-radius: 8px; text-align: center; font-size: 12px; color: #fff; margin-top: 16px;position: fixed; left: 8px; bottom: 8px; z-index: 10; background: rgba(0, 0, 0, 0.8); padding: 4px 8px;">Made with <img src="https://enzostvs-deepsite.hf.space/logo.svg" alt="DeepSite Logo" style="width: 16px; height: 16px; vertical-align: middle;display:inline-block;margin-right:3px;filter:brightness(0) invert(1);"><a href="https://enzostvs-deepsite.hf.space" style="color: #fff;text-decoration: underline;" target="_blank" >DeepSite</a> - 🧬 <a href="https://enzostvs-deepsite.hf.space?remix=44444t/clown-anger" style="color: #fff;text-decoration: underline;" target="_blank" >Remix</a></p></body>
</html>